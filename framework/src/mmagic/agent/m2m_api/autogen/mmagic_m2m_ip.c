/*
 * Copyright 2025 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 *
 * Note: The corresponding headers files must be included BEFORE this def file. Additionally this
 *       file should only be in one (and only one) compilation unit (.c/.cpp file).
 */

#include "mmconfig.h"
#include "mmutils.h"
#include "core/autogen/mmagic_core_ip.h"
#include "core/autogen/mmagic_core_types.h"
#include "m2m_api/autogen/mmagic_m2m_ip.h"
#include "m2m_api/autogen/mmagic_m2m_internal.h"
#include "m2m_api/mmagic_m2m_agent.h"

/* Maximum allowed length of any value string, needs to accomodate IP and MAC address strings */
#define MAX_VAL_LEN     32

/********* M2M Command Handlers **********/
static struct mmbuf *mmagic_m2m_ip_get(struct mmagic_m2m_agent *agent,
                                       uint8_t sid, uint8_t subcommand, struct mmbuf *commandbuffer)
{
    MM_UNUSED(sid);
    MM_UNUSED(commandbuffer);

    struct mmagic_ip_data *data = mmagic_data_get_ip(&agent->core);
    switch (subcommand)
    {
    case mmagic_ip_var_ip_addr:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_get, subcommand,
                                          MMAGIC_STATUS_OK, &data->config.ip_addr,
                                          sizeof(data->config.ip_addr));

    case mmagic_ip_var_netmask:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_get, subcommand,
                                          MMAGIC_STATUS_OK, &data->config.netmask,
                                          sizeof(data->config.netmask));

    case mmagic_ip_var_gateway:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_get, subcommand,
                                          MMAGIC_STATUS_OK, &data->config.gateway,
                                          sizeof(data->config.gateway));

    case mmagic_ip_var_dns_server0:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_get, subcommand,
                                          MMAGIC_STATUS_OK, &data->config.dns_server0,
                                          sizeof(data->config.dns_server0));

    case mmagic_ip_var_dns_server1:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_get, subcommand,
                                          MMAGIC_STATUS_OK, &data->config.dns_server1,
                                          sizeof(data->config.dns_server1));

    case mmagic_ip_var_dhcp_enabled:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_get, subcommand,
                                          MMAGIC_STATUS_OK, &data->config.dhcp_enabled,
                                          sizeof(data->config.dhcp_enabled));

    case mmagic_ip_var_dhcp_offload:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_get, subcommand,
                                          MMAGIC_STATUS_OK, &data->config.dhcp_offload,
                                          sizeof(data->config.dhcp_offload));

    default:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_get, subcommand,
                                          MMAGIC_STATUS_NOT_FOUND, NULL, 0);
    }
}

static struct mmbuf *mmagic_m2m_ip_set(struct mmagic_m2m_agent *agent,
                                       uint8_t sid, uint8_t subcommand, struct mmbuf *commandbuffer)
{
    MM_UNUSED(sid);
    struct mmagic_ip_data *data = mmagic_data_get_ip(&agent->core);
    void *args = (void *)mmbuf_get_data_start(commandbuffer);
    switch (subcommand)
    {
    case mmagic_ip_var_ip_addr:
        memcpy(&data->config.ip_addr, args, sizeof(data->config.ip_addr));
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set,
                                          subcommand, MMAGIC_STATUS_OK, NULL, 0);
        break;

    case mmagic_ip_var_netmask:
        memcpy(&data->config.netmask, args, sizeof(data->config.netmask));
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set,
                                          subcommand, MMAGIC_STATUS_OK, NULL, 0);
        break;

    case mmagic_ip_var_gateway:
        memcpy(&data->config.gateway, args, sizeof(data->config.gateway));
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set,
                                          subcommand, MMAGIC_STATUS_OK, NULL, 0);
        break;

    case mmagic_ip_var_dns_server0:
        memcpy(&data->config.dns_server0, args, sizeof(data->config.dns_server0));
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set,
                                          subcommand, MMAGIC_STATUS_OK, NULL, 0);
        break;

    case mmagic_ip_var_dns_server1:
        memcpy(&data->config.dns_server1, args, sizeof(data->config.dns_server1));
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set,
                                          subcommand, MMAGIC_STATUS_OK, NULL, 0);
        break;

    case mmagic_ip_var_dhcp_enabled:
        memcpy(&data->config.dhcp_enabled, args, sizeof(data->config.dhcp_enabled));
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set,
                                          subcommand, MMAGIC_STATUS_OK, NULL, 0);
        break;

    case mmagic_ip_var_dhcp_offload:
        memcpy(&data->config.dhcp_offload, args, sizeof(data->config.dhcp_offload));
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set,
                                          subcommand, MMAGIC_STATUS_OK, NULL, 0);
        break;

    default:
        return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set,
                                          subcommand, MMAGIC_STATUS_NOT_FOUND, NULL, 0);
    }
}

static struct mmbuf *mmagic_m2m_ip_load(struct mmagic_m2m_agent *agent,
                                        uint8_t sid, uint8_t subcommand,
                                        struct mmbuf *commandbuffer)
{
    MM_UNUSED(sid);
    MM_UNUSED(commandbuffer);

    mmagic_core_ip_load_all(&agent->core);

    return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_load,
                                      subcommand, MMAGIC_STATUS_OK, NULL, 0);
}

static struct mmbuf *mmagic_m2m_ip_commit(struct mmagic_m2m_agent *agent,
                                          uint8_t sid, uint8_t subcommand,
                                          struct mmbuf *commandbuffer)
{
    MM_UNUSED(sid);
    MM_UNUSED(commandbuffer);

    mmagic_core_ip_save_all(&agent->core);

    return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_commit,
                                      subcommand, MMAGIC_STATUS_OK, NULL, 0);
}

static struct mmbuf *mmagic_m2m_ip_status(struct mmagic_m2m_agent *agent,
                                          uint8_t sid, uint8_t subcommand,
                                          struct mmbuf *commandbuffer)
{
    enum mmagic_status status;
    MM_UNUSED(commandbuffer);
    MM_UNUSED(sid);
    struct mmagic_core_ip_status_rsp_args rsp_args = { };
    status = mmagic_core_ip_status(&agent->core, &rsp_args);
    return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_status,
                                      subcommand, status, &rsp_args, sizeof(rsp_args));
}

static struct mmbuf *mmagic_m2m_ip_reload(struct mmagic_m2m_agent *agent,
                                          uint8_t sid, uint8_t subcommand,
                                          struct mmbuf *commandbuffer)
{
    enum mmagic_status status;
    MM_UNUSED(commandbuffer);
    MM_UNUSED(sid);
    status = mmagic_core_ip_reload(&agent->core);
    return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_reload,
                                      subcommand, status, NULL, 0);
}

static struct mmbuf *mmagic_m2m_ip_enable_tcp_keepalive_offload(struct mmagic_m2m_agent *agent,
                                                                uint8_t sid, uint8_t subcommand,
                                                                struct mmbuf *commandbuffer)
{
    enum mmagic_status status;
    struct mmagic_core_ip_enable_tcp_keepalive_offload_cmd_args *cmd_args =
        (struct mmagic_core_ip_enable_tcp_keepalive_offload_cmd_args *)mmbuf_get_data_start(
            commandbuffer);
    MM_UNUSED(sid);
    status = mmagic_core_ip_enable_tcp_keepalive_offload(&agent->core, cmd_args);
    return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_enable_tcp_keepalive_offload,
                                      subcommand, status, NULL, 0);
}

static struct mmbuf *mmagic_m2m_ip_disable_tcp_keepalive_offload(struct mmagic_m2m_agent *agent,
                                                                 uint8_t sid, uint8_t subcommand,
                                                                 struct mmbuf *commandbuffer)
{
    enum mmagic_status status;
    MM_UNUSED(commandbuffer);
    MM_UNUSED(sid);
    status = mmagic_core_ip_disable_tcp_keepalive_offload(&agent->core);
    return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_disable_tcp_keepalive_offload,
                                      subcommand, status, NULL, 0);
}

static struct mmbuf *mmagic_m2m_ip_set_whitelist_filter(struct mmagic_m2m_agent *agent,
                                                        uint8_t sid, uint8_t subcommand,
                                                        struct mmbuf *commandbuffer)
{
    enum mmagic_status status;
    struct mmagic_core_ip_set_whitelist_filter_cmd_args *cmd_args =
        (struct mmagic_core_ip_set_whitelist_filter_cmd_args *)mmbuf_get_data_start(commandbuffer);
    MM_UNUSED(sid);
    status = mmagic_core_ip_set_whitelist_filter(&agent->core, cmd_args);
    return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_set_whitelist_filter,
                                      subcommand, status, NULL, 0);
}

static struct mmbuf *mmagic_m2m_ip_clear_whitelist_filter(struct mmagic_m2m_agent *agent,
                                                          uint8_t sid, uint8_t subcommand,
                                                          struct mmbuf *commandbuffer)
{
    enum mmagic_status status;
    MM_UNUSED(commandbuffer);
    MM_UNUSED(sid);
    status = mmagic_core_ip_clear_whitelist_filter(&agent->core);
    return mmagic_m2m_create_response(mmagic_ip, mmagic_ip_cmd_clear_whitelist_filter,
                                      subcommand, status, NULL, 0);
}

struct mmbuf *mmagic_m2m_ip_process(struct mmagic_m2m_agent *agent, uint8_t sid,
                                    struct mmagic_m2m_command_header *header, struct mmbuf *cmd_buf)
{
    if (header)
    {
        switch (header->command)
        {
        case mmagic_ip_cmd_get:
            return mmagic_m2m_ip_get(agent, sid, header->subcommand, cmd_buf);
            break;

        case mmagic_ip_cmd_set:
            return mmagic_m2m_ip_set(agent, sid, header->subcommand, cmd_buf);
            break;

        case mmagic_ip_cmd_load:
            return mmagic_m2m_ip_load(agent, sid, header->subcommand, cmd_buf);
            break;

        case mmagic_ip_cmd_commit:
            return mmagic_m2m_ip_commit(agent, sid, header->subcommand, cmd_buf);
            break;

        case mmagic_ip_cmd_status:
            return mmagic_m2m_ip_status(agent, sid, header->subcommand, cmd_buf);
            break;

        case mmagic_ip_cmd_reload:
            return mmagic_m2m_ip_reload(agent, sid, header->subcommand, cmd_buf);
            break;

        case mmagic_ip_cmd_enable_tcp_keepalive_offload:
            return mmagic_m2m_ip_enable_tcp_keepalive_offload(agent, sid, header->subcommand,
                                                              cmd_buf);
            break;

        case mmagic_ip_cmd_disable_tcp_keepalive_offload:
            return mmagic_m2m_ip_disable_tcp_keepalive_offload(agent, sid, header->subcommand,
                                                               cmd_buf);
            break;

        case mmagic_ip_cmd_set_whitelist_filter:
            return mmagic_m2m_ip_set_whitelist_filter(agent, sid, header->subcommand, cmd_buf);
            break;

        case mmagic_ip_cmd_clear_whitelist_filter:
            return mmagic_m2m_ip_clear_whitelist_filter(agent, sid, header->subcommand, cmd_buf);
            break;

        default:
            return mmagic_m2m_create_response(header->subsystem, header->command,
                                              header->subcommand, MMAGIC_STATUS_NOT_SUPPORTED, NULL,
                                              0);
        }
    }
    else
    {
        return mmagic_m2m_create_response(0, 0, 0, MMAGIC_STATUS_ERROR, NULL, 0);
    }
}
