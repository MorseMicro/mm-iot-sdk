/*
 * Copyright 2024 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 *
 * Note: The corresponding headers files must be included BEFORE this def file. Additionally this
 *       file should only be in one (and only one) compilation unit (.c/.cpp file).
 */

#include "mmconfig.h"
#include "mmutils.h"
#include "cli/mmagic_cli.h"
#include "cli/autogen/mmagic_cli_internal.h"

/* Maximum allowed length of any value string, needs to accomodate IP and MAC address strings */
#define MAX_VAL_LEN     32

/********* Getters **********/

int mmagic_cli_wlan_get_ampdu_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.ampdu_enabled");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = bool_to_string(&data->config.ampdu_enabled, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_bssid(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.bssid");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = struct_mac_addr_to_string(&data->config.bssid, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_cac_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.cac_enabled");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = bool_to_string(&data->config.cac_enabled, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_country_code(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.country_code");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = struct_country_code_to_string(&data->config.country_code, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_fragment_threshold(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.fragment_threshold");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = uint32_t_to_string(&data->config.fragment_threshold, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_max_health_check_intvl_ms(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.max_health_check_intvl_ms");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = uint32_t_to_string(&data->config.max_health_check_intvl_ms, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_min_health_check_intvl_ms(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.min_health_check_intvl_ms");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = uint32_t_to_string(&data->config.min_health_check_intvl_ms, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_offload_arp_refresh_s(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.offload_arp_refresh_s");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = uint32_t_to_string(&data->config.offload_arp_refresh_s, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_offload_arp_response(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.offload_arp_response");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = bool_to_string(&data->config.offload_arp_response, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_password(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.password");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = struct_string_32_to_string(&data->config.password, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_pmf_mode(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.pmf_mode");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = enum_pmf_mode_to_string(&data->config.pmf_mode, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_power_save_mode(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.power_save_mode");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = enum_power_save_mode_to_string(&data->config.power_save_mode, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_raw_priority(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.raw_priority");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = int16_t_to_string(&data->config.raw_priority, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_rts_threshold(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.rts_threshold");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = uint32_t_to_string(&data->config.rts_threshold, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_security(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.security");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = enum_security_type_to_string(&data->config.security, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_sgi_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.sgi_enabled");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = bool_to_string(&data->config.sgi_enabled, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_ssid(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.ssid");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = struct_string_32_to_string(&data->config.ssid, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_station_type(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.station_type");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = enum_station_type_to_string(&data->config.station_type, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_subbands_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    int len = MMAGIC_CLI_PRINT_BUF_LEN - 1;
    int written = 0;

    written = snprintf(&buf[written], len, "%-30s", "wlan.subbands_enabled");
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    written = bool_to_string(&data->config.subbands_enabled, &buf[written], len);
    if (written < 0 || written > len)
    {
        return -1;
    }
    len -= written;

    embeddedCliPrint(cli, buf);

    return 0;
}


/********* Setters **********/

int mmagic_cli_wlan_set_ampdu_enabled(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_bool(&data->config.ampdu_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_ampdu_enabled(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_bssid(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_struct_mac_addr(&data->config.bssid, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_bssid(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_cac_enabled(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_bool(&data->config.cac_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_cac_enabled(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_country_code(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_struct_country_code(&data->config.country_code, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_country_code(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_fragment_threshold(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_uint32_t(&data->config.fragment_threshold, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_fragment_threshold(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_max_health_check_intvl_ms(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_uint32_t(&data->config.max_health_check_intvl_ms, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_max_health_check_intvl_ms(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_min_health_check_intvl_ms(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_uint32_t(&data->config.min_health_check_intvl_ms, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_min_health_check_intvl_ms(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_offload_arp_refresh_s(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_uint32_t(&data->config.offload_arp_refresh_s, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_offload_arp_refresh_s(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_offload_arp_response(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_bool(&data->config.offload_arp_response, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_offload_arp_response(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_password(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_struct_string_32(&data->config.password, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_password(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_pmf_mode(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_enum_pmf_mode(&data->config.pmf_mode, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_pmf_mode(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_power_save_mode(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_enum_power_save_mode(&data->config.power_save_mode, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_power_save_mode(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_raw_priority(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_int16_t(&data->config.raw_priority, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_raw_priority(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_rts_threshold(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_uint32_t(&data->config.rts_threshold, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_rts_threshold(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_security(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_enum_security_type(&data->config.security, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_security(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_sgi_enabled(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_bool(&data->config.sgi_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_sgi_enabled(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_ssid(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_struct_string_32(&data->config.ssid, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_ssid(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_station_type(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_enum_station_type(&data->config.station_type, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_station_type(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_subbands_enabled(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (string_to_bool(&data->config.subbands_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_subbands_enabled(core, cli);

    return 0;
}


/********* Dictionary **********/
struct mmagic_cli_config_elem wlan_cli_config_vars[] = {
    {"ampdu_enabled", mmagic_cli_wlan_get_ampdu_enabled, mmagic_cli_wlan_set_ampdu_enabled},
    {"bssid", mmagic_cli_wlan_get_bssid, mmagic_cli_wlan_set_bssid},
    {"cac_enabled", mmagic_cli_wlan_get_cac_enabled, mmagic_cli_wlan_set_cac_enabled},
    {"country_code", mmagic_cli_wlan_get_country_code, mmagic_cli_wlan_set_country_code},
    {"fragment_threshold", mmagic_cli_wlan_get_fragment_threshold, mmagic_cli_wlan_set_fragment_threshold},
    {"max_health_check_intvl_ms", mmagic_cli_wlan_get_max_health_check_intvl_ms, mmagic_cli_wlan_set_max_health_check_intvl_ms},
    {"min_health_check_intvl_ms", mmagic_cli_wlan_get_min_health_check_intvl_ms, mmagic_cli_wlan_set_min_health_check_intvl_ms},
    {"offload_arp_refresh_s", mmagic_cli_wlan_get_offload_arp_refresh_s, mmagic_cli_wlan_set_offload_arp_refresh_s},
    {"offload_arp_response", mmagic_cli_wlan_get_offload_arp_response, mmagic_cli_wlan_set_offload_arp_response},
    {"password", mmagic_cli_wlan_get_password, mmagic_cli_wlan_set_password},
    {"pmf_mode", mmagic_cli_wlan_get_pmf_mode, mmagic_cli_wlan_set_pmf_mode},
    {"power_save_mode", mmagic_cli_wlan_get_power_save_mode, mmagic_cli_wlan_set_power_save_mode},
    {"raw_priority", mmagic_cli_wlan_get_raw_priority, mmagic_cli_wlan_set_raw_priority},
    {"rts_threshold", mmagic_cli_wlan_get_rts_threshold, mmagic_cli_wlan_set_rts_threshold},
    {"security", mmagic_cli_wlan_get_security, mmagic_cli_wlan_set_security},
    {"sgi_enabled", mmagic_cli_wlan_get_sgi_enabled, mmagic_cli_wlan_set_sgi_enabled},
    {"ssid", mmagic_cli_wlan_get_ssid, mmagic_cli_wlan_set_ssid},
    {"station_type", mmagic_cli_wlan_get_station_type, mmagic_cli_wlan_set_station_type},
    {"subbands_enabled", mmagic_cli_wlan_get_subbands_enabled, mmagic_cli_wlan_set_subbands_enabled},
};

/********* WLAN Configuration Getter/Setter Handlers **********/
void mmagic_cli_wlan_get(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var)
{
    struct mmagic_data *core = &ctx->core;

    if (config_var == NULL)
    {
        embeddedCliPrint(cli, "Invalid argument");
        return;
    }

    uint32_t num_elements = sizeof(wlan_cli_config_vars)/sizeof(wlan_cli_config_vars[0]);

    if (!strcmp("all", config_var))
    {
        for (; num_elements > 0; num_elements--)
        {
            wlan_cli_config_vars[num_elements-1].get(core, cli);
        }
        return;
    }

    struct mmagic_cli_config_elem *elem = mmagic_cli_element_search(wlan_cli_config_vars, num_elements, config_var);
    if (elem == NULL)
    {
        embeddedCliPrint(cli, "Unable to find config variable");
        return;
    }

    if (elem->get == NULL)
    {
        embeddedCliPrint(cli, "Unable to find getter");
        return;
    }

    if (elem->get(core, cli))
    {
        embeddedCliPrint(cli, "Get function failed");
    }
}

void mmagic_cli_wlan_set(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var, const char *val)
{
    struct mmagic_data *core = &ctx->core;

    uint32_t num_elements = sizeof(wlan_cli_config_vars)/sizeof(wlan_cli_config_vars[0]);

    struct mmagic_cli_config_elem *elem = mmagic_cli_element_search(wlan_cli_config_vars, num_elements, config_var);
    if (elem == NULL)
    {
        mmagic_cli_printf(cli, "Unable to find config variable wlan.%s", config_var);
        return;
    }

    if (elem->set == NULL)
    {
        embeddedCliPrint(cli, "Unable to find setter");
        return;
    }

    if (elem->set(core, cli, val))
    {
        mmagic_cli_printf(cli, "Set wlan.%s failed", elem->name);
    }
}

/********* Persistence *******/
void mmagic_cli_wlan_commit(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var)
{
    if ((config_var != NULL) && strcmp("all", config_var))
    {
        embeddedCliPrint(cli, "Unexpected argument! Only \'wlan\' or \'wlan.all\' supported.");
        return;
    }

    mmagic_core_wlan_save_all(&ctx->core);
    
}

void mmagic_cli_wlan_load(struct mmagic_cli *ctx, EmbeddedCli *cli)
{
    MM_UNUSED(cli);
    mmagic_core_wlan_load_all(&ctx->core);
    
}

/********* CLI Command Handlers **********/

void mmagic_cli_wlan_connect(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_disconnect(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_scan(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_get_rssi(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_get_mac_addr(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_wnm_sleep(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_beacon_monitor_enable(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_beacon_monitor_disable(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_standby_enter(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_standby_exit(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_standby_set_status_payload(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_standby_set_wake_filter(EmbeddedCli *cli, char *args, void *context);
void mmagic_cli_wlan_standby_set_config(EmbeddedCli *cli, char *args, void *context);

/********* Register bindings function definition **********/
void mmagic_cli_wlan_register_bindings(EmbeddedCli *cli, struct mmagic_data *core)
{
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-connect",
        "Brings up the WLAN interface and connects to the AP with configured parameters.",
        true,
        core,
        mmagic_cli_wlan_connect
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-disconnect",
        "Disconnects and brings down the WLAN interface.",
        true,
        core,
        mmagic_cli_wlan_disconnect
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-scan",
        "Starts an undirected scan for available networks.",
        true,
        core,
        mmagic_cli_wlan_scan
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-get_rssi",
        "Retrieves the RSSI if the WLAN interface is up, else 0.",
        true,
        core,
        mmagic_cli_wlan_get_rssi
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-get_mac_addr",
        "Retrieves the MAC address if the WLAN interface is up.",
        true,
        core,
        mmagic_cli_wlan_get_mac_addr
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-wnm_sleep",
        "Requests entry or exit from extended sleep (wnm sleep) if the WLAN interface is up.",
        true,
        core,
        mmagic_cli_wlan_wnm_sleep
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-beacon_monitor_enable",
        "Enable beacon monitoring with the given filter settings. If beacon monitoring is already enabled it will be reconfigured with the given arguments.",
        true,
        core,
        mmagic_cli_wlan_beacon_monitor_enable
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-beacon_monitor_disable",
        "Disable beacon monitoring. If beacon monitor is not enabled then this has no effect.",
        true,
        core,
        mmagic_cli_wlan_beacon_monitor_disable
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_enter",
        "This puts the Morse chip into standby mode allowing the host processor to go to sleep while the Morse chip takes over certain functionality to keep the connection alive with the provision to wake up the host processor when certain conditions are met.",
        true,
        core,
        mmagic_cli_wlan_standby_enter
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_exit",
        "Forces the Morse chip to exit standby mode. There may be certain instances such as a timer expiry, which cause the host chip to wake up independant of the Morse chip. In such situations, the host calls this function to instruct the Morse chip to exit standby mode and return to normal operating mode.",
        true,
        core,
        mmagic_cli_wlan_standby_exit
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_set_status_payload",
        "Sets the user payload for the standby status packet. Once standby mode is enabled, the Morse chip will periodically emit a UDP standby status packet regardless of whether it is in standby or not. The UDP packet will also be sent immediately upon entering or exiting Standby mode. If this command is not executed then the standby status packet will contain no payload.",
        true,
        core,
        mmagic_cli_wlan_standby_set_status_payload
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_set_wake_filter",
        "Configures the standby mode UDP wake packet filter. The system can be woken up from standby mode by sending it a UDP wake packet. If a wake filter is set using this function then the wake packet will only wake up the system if the specified filter pattern matches the payload at the specified offset within the payload. If this command is not executed then any wake packet will wake up the system.",
        true,
        core,
        mmagic_cli_wlan_standby_set_wake_filter
    });
    
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_set_config",
        "Sets the standby mode configuration parameters. If this command is not executed then the defaults are as specified.",
        true,
        core,
        mmagic_cli_wlan_standby_set_config
    });
    
}

void mmagic_cli_wlan_init(struct mmagic_cli *ctx)
{
    /* Register Commands */
    mmagic_cli_wlan_register_bindings(ctx->cli, &ctx->core);

    /* Register config variable accessor functions */
    struct mmagic_cli_config_accessor *accessor =
        (struct mmagic_cli_config_accessor *)mmosal_malloc(sizeof(*accessor));
    MMOSAL_ASSERT(accessor);

    mmosal_safer_strcpy(accessor->name, "wlan", sizeof(accessor->name));
    accessor->get = mmagic_cli_wlan_get;
    accessor->set = mmagic_cli_wlan_set;
    accessor->commit = mmagic_cli_wlan_commit;
    accessor->next = NULL;

    mmagic_cli_register_config_accessor(ctx, accessor);
}
