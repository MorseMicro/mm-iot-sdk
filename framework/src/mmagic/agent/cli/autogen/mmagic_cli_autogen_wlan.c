/*
 * Copyright 2025 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 *
 * Note: The corresponding headers files must be included BEFORE this def file. Additionally this
 *       file should only be in one (and only one) compilation unit (.c/.cpp file).
 */
#include <ctype.h>

#include "mmconfig.h"
#include "mmutils.h"
#include "cli/mmagic_cli.h"
#include "cli/autogen/mmagic_cli_internal.h"

/*
 * The fixed width that the key will be padded to, with trailing spaces, before the value is
 * printed.
 */
#define KEY_NAME_PADDING 32

/********* Getters **********/

int mmagic_cli_wlan_get_country_code(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.country_code";
    MM_STATIC_ASSERT((sizeof("wlan.country_code") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_struct_country_code_to_string(&data->config.country_code,
                                                   &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_ssid(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.ssid";
    MM_STATIC_ASSERT((sizeof("wlan.ssid") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_string32_to_string(&data->config.ssid,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_password(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.password";
    MM_STATIC_ASSERT((sizeof("wlan.password") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_string100_to_string(&data->config.password,
                                         &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_security(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.security";
    MM_STATIC_ASSERT((sizeof("wlan.security") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_enum_security_type_to_string(data->config.security,
                                                  &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_raw_priority(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.raw_priority";
    MM_STATIC_ASSERT((sizeof("wlan.raw_priority") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_int16_t_to_string(data->config.raw_priority,
                                       &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_bssid(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.bssid";
    MM_STATIC_ASSERT((sizeof("wlan.bssid") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_struct_mac_addr_to_string(&data->config.bssid,
                                               &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_pmf_mode(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.pmf_mode";
    MM_STATIC_ASSERT((sizeof("wlan.pmf_mode") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_enum_pmf_mode_to_string(data->config.pmf_mode,
                                             &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_station_type(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.station_type";
    MM_STATIC_ASSERT((sizeof("wlan.station_type") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_enum_station_type_to_string(data->config.station_type,
                                                 &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_rts_threshold(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.rts_threshold";
    MM_STATIC_ASSERT((sizeof("wlan.rts_threshold") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_uint32_t_to_string(data->config.rts_threshold,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_sgi_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.sgi_enabled";
    MM_STATIC_ASSERT((sizeof("wlan.sgi_enabled") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.sgi_enabled,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_subbands_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.subbands_enabled";
    MM_STATIC_ASSERT((sizeof("wlan.subbands_enabled") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.subbands_enabled,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_ampdu_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.ampdu_enabled";
    MM_STATIC_ASSERT((sizeof("wlan.ampdu_enabled") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.ampdu_enabled,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_power_save_mode(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.power_save_mode";
    MM_STATIC_ASSERT((sizeof("wlan.power_save_mode") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_enum_power_save_mode_to_string(data->config.power_save_mode,
                                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_fragment_threshold(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.fragment_threshold";
    MM_STATIC_ASSERT((sizeof("wlan.fragment_threshold") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_uint32_t_to_string(data->config.fragment_threshold,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_cac_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.cac_enabled";
    MM_STATIC_ASSERT((sizeof("wlan.cac_enabled") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.cac_enabled,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_offload_arp_response(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.offload_arp_response";
    MM_STATIC_ASSERT((sizeof("wlan.offload_arp_response") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.offload_arp_response,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_offload_arp_refresh_s(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.offload_arp_refresh_s";
    MM_STATIC_ASSERT((sizeof("wlan.offload_arp_refresh_s") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_uint32_t_to_string(data->config.offload_arp_refresh_s,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_min_health_check_intvl_ms(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.min_health_check_intvl_ms";
    MM_STATIC_ASSERT((sizeof("wlan.min_health_check_intvl_ms") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_uint32_t_to_string(data->config.min_health_check_intvl_ms,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_max_health_check_intvl_ms(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.max_health_check_intvl_ms";
    MM_STATIC_ASSERT((sizeof("wlan.max_health_check_intvl_ms") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_uint32_t_to_string(data->config.max_health_check_intvl_ms,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_ndp_probe_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.ndp_probe_enabled";
    MM_STATIC_ASSERT((sizeof("wlan.ndp_probe_enabled") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.ndp_probe_enabled,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_sta_scan_interval_base_s(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.sta_scan_interval_base_s";
    MM_STATIC_ASSERT((sizeof("wlan.sta_scan_interval_base_s") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_uint16_t_to_string(data->config.sta_scan_interval_base_s,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_sta_scan_interval_limit_s(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.sta_scan_interval_limit_s";
    MM_STATIC_ASSERT((sizeof("wlan.sta_scan_interval_limit_s") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_uint16_t_to_string(data->config.sta_scan_interval_limit_s,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_qos_0_params(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.qos_0_params";
    MM_STATIC_ASSERT((sizeof("wlan.qos_0_params") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_string32_to_string(&data->config.qos_0_params,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_qos_1_params(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.qos_1_params";
    MM_STATIC_ASSERT((sizeof("wlan.qos_1_params") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_string32_to_string(&data->config.qos_1_params,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_qos_2_params(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.qos_2_params";
    MM_STATIC_ASSERT((sizeof("wlan.qos_2_params") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_string32_to_string(&data->config.qos_2_params,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_qos_3_params(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.qos_3_params";
    MM_STATIC_ASSERT((sizeof("wlan.qos_3_params") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_string32_to_string(&data->config.qos_3_params,
                                        &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_mcs10_mode(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.mcs10_mode";
    MM_STATIC_ASSERT((sizeof("wlan.mcs10_mode") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_enum_mcs10_mode_to_string(data->config.mcs10_mode,
                                               &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_sta_evt_en(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.sta_evt_en";
    MM_STATIC_ASSERT((sizeof("wlan.sta_evt_en") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.sta_evt_en,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_wlan_get_duty_cycle_mode(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);
    const char *key_name = "wlan.duty_cycle_mode";
    MM_STATIC_ASSERT((sizeof("wlan.duty_cycle_mode") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_enum_duty_cycle_mode_to_string(data->config.duty_cycle_mode,
                                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

/********* Setters **********/

int mmagic_cli_wlan_set_country_code(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_struct_country_code(&data->config.country_code, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_country_code(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_ssid(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_string32(&data->config.ssid, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_ssid(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_password(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_string100(&data->config.password, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_password(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_security(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_enum_security_type(&data->config.security, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_security(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_raw_priority(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_int16_t(&data->config.raw_priority, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_raw_priority(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_bssid(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_struct_mac_addr(&data->config.bssid, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_bssid(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_pmf_mode(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_enum_pmf_mode(&data->config.pmf_mode, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_pmf_mode(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_station_type(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_enum_station_type(&data->config.station_type, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_station_type(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_rts_threshold(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_uint32_t(&data->config.rts_threshold, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_rts_threshold(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_sgi_enabled(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_bool(&data->config.sgi_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_sgi_enabled(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_subbands_enabled(struct mmagic_data *core, EmbeddedCli *cli,
                                         const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_bool(&data->config.subbands_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_subbands_enabled(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_ampdu_enabled(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_bool(&data->config.ampdu_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_ampdu_enabled(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_power_save_mode(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_enum_power_save_mode(&data->config.power_save_mode, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_power_save_mode(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_fragment_threshold(struct mmagic_data *core, EmbeddedCli *cli,
                                           const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_uint32_t(&data->config.fragment_threshold, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_fragment_threshold(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_cac_enabled(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_bool(&data->config.cac_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_cac_enabled(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_offload_arp_response(struct mmagic_data *core, EmbeddedCli *cli,
                                             const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_bool(&data->config.offload_arp_response, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_offload_arp_response(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_offload_arp_refresh_s(struct mmagic_data *core, EmbeddedCli *cli,
                                              const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_uint32_t(&data->config.offload_arp_refresh_s, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_offload_arp_refresh_s(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_min_health_check_intvl_ms(struct mmagic_data *core, EmbeddedCli *cli,
                                                  const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_uint32_t(&data->config.min_health_check_intvl_ms, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_min_health_check_intvl_ms(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_max_health_check_intvl_ms(struct mmagic_data *core, EmbeddedCli *cli,
                                                  const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_uint32_t(&data->config.max_health_check_intvl_ms, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_max_health_check_intvl_ms(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_ndp_probe_enabled(struct mmagic_data *core, EmbeddedCli *cli,
                                          const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_bool(&data->config.ndp_probe_enabled, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_ndp_probe_enabled(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_sta_scan_interval_base_s(struct mmagic_data *core, EmbeddedCli *cli,
                                                 const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_uint16_t(&data->config.sta_scan_interval_base_s, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_sta_scan_interval_base_s(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_sta_scan_interval_limit_s(struct mmagic_data *core, EmbeddedCli *cli,
                                                  const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_uint16_t(&data->config.sta_scan_interval_limit_s, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_sta_scan_interval_limit_s(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_qos_0_params(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_string32(&data->config.qos_0_params, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_qos_0_params(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_qos_1_params(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_string32(&data->config.qos_1_params, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_qos_1_params(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_qos_2_params(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_string32(&data->config.qos_2_params, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_qos_2_params(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_qos_3_params(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_string32(&data->config.qos_3_params, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_qos_3_params(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_mcs10_mode(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_enum_mcs10_mode(&data->config.mcs10_mode, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_mcs10_mode(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_sta_evt_en(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_bool(&data->config.sta_evt_en, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_sta_evt_en(core, cli);

    return 0;
}

int mmagic_cli_wlan_set_duty_cycle_mode(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_wlan_data *data = mmagic_data_get_wlan(core);

    if (mmagic_string_to_enum_duty_cycle_mode(&data->config.duty_cycle_mode, val))
    {
        return -1;
    }

    mmagic_cli_wlan_get_duty_cycle_mode(core, cli);

    return 0;
}

/********* Dictionary **********
 *
 * This list must be in alphabetical order as @c mmagic_cli_element_search() is implemented using
 * a binary search which requires an ordered list.
 */
struct mmagic_cli_config_elem wlan_cli_config_vars[] = {
    {"ampdu_enabled", mmagic_cli_wlan_get_ampdu_enabled, mmagic_cli_wlan_set_ampdu_enabled},
    {"bssid", mmagic_cli_wlan_get_bssid, mmagic_cli_wlan_set_bssid},
    {"cac_enabled", mmagic_cli_wlan_get_cac_enabled, mmagic_cli_wlan_set_cac_enabled},
    {"country_code", mmagic_cli_wlan_get_country_code, mmagic_cli_wlan_set_country_code},
    {"duty_cycle_mode", mmagic_cli_wlan_get_duty_cycle_mode, mmagic_cli_wlan_set_duty_cycle_mode},
    {"fragment_threshold", mmagic_cli_wlan_get_fragment_threshold,
     mmagic_cli_wlan_set_fragment_threshold},
    {"max_health_check_intvl_ms", mmagic_cli_wlan_get_max_health_check_intvl_ms,
     mmagic_cli_wlan_set_max_health_check_intvl_ms},
    {"mcs10_mode", mmagic_cli_wlan_get_mcs10_mode, mmagic_cli_wlan_set_mcs10_mode},
    {"min_health_check_intvl_ms", mmagic_cli_wlan_get_min_health_check_intvl_ms,
     mmagic_cli_wlan_set_min_health_check_intvl_ms},
    {"ndp_probe_enabled", mmagic_cli_wlan_get_ndp_probe_enabled,
     mmagic_cli_wlan_set_ndp_probe_enabled},
    {"offload_arp_refresh_s", mmagic_cli_wlan_get_offload_arp_refresh_s,
     mmagic_cli_wlan_set_offload_arp_refresh_s},
    {"offload_arp_response", mmagic_cli_wlan_get_offload_arp_response,
     mmagic_cli_wlan_set_offload_arp_response},
    {"password", mmagic_cli_wlan_get_password, mmagic_cli_wlan_set_password},
    {"pmf_mode", mmagic_cli_wlan_get_pmf_mode, mmagic_cli_wlan_set_pmf_mode},
    {"power_save_mode", mmagic_cli_wlan_get_power_save_mode, mmagic_cli_wlan_set_power_save_mode},
    {"qos_0_params", mmagic_cli_wlan_get_qos_0_params, mmagic_cli_wlan_set_qos_0_params},
    {"qos_1_params", mmagic_cli_wlan_get_qos_1_params, mmagic_cli_wlan_set_qos_1_params},
    {"qos_2_params", mmagic_cli_wlan_get_qos_2_params, mmagic_cli_wlan_set_qos_2_params},
    {"qos_3_params", mmagic_cli_wlan_get_qos_3_params, mmagic_cli_wlan_set_qos_3_params},
    {"raw_priority", mmagic_cli_wlan_get_raw_priority, mmagic_cli_wlan_set_raw_priority},
    {"rts_threshold", mmagic_cli_wlan_get_rts_threshold, mmagic_cli_wlan_set_rts_threshold},
    {"security", mmagic_cli_wlan_get_security, mmagic_cli_wlan_set_security},
    {"sgi_enabled", mmagic_cli_wlan_get_sgi_enabled, mmagic_cli_wlan_set_sgi_enabled},
    {"ssid", mmagic_cli_wlan_get_ssid, mmagic_cli_wlan_set_ssid},
    {"sta_evt_en", mmagic_cli_wlan_get_sta_evt_en, mmagic_cli_wlan_set_sta_evt_en},
    {"sta_scan_interval_base_s", mmagic_cli_wlan_get_sta_scan_interval_base_s,
     mmagic_cli_wlan_set_sta_scan_interval_base_s},
    {"sta_scan_interval_limit_s", mmagic_cli_wlan_get_sta_scan_interval_limit_s,
     mmagic_cli_wlan_set_sta_scan_interval_limit_s},
    {"station_type", mmagic_cli_wlan_get_station_type, mmagic_cli_wlan_set_station_type},
    {"subbands_enabled", mmagic_cli_wlan_get_subbands_enabled,
     mmagic_cli_wlan_set_subbands_enabled},
};

/********* WLAN Configuration Getter/Setter Handlers **********/
void mmagic_cli_wlan_get(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var)
{
    struct mmagic_data *core = &ctx->core;

    if (config_var == NULL)
    {
        embeddedCliPrint(cli, "Invalid argument");
        return;
    }

    uint32_t num_elements = sizeof(wlan_cli_config_vars) / sizeof(wlan_cli_config_vars[0]);

    if (!strcmp("all", config_var))
    {
        for (; num_elements > 0; num_elements--)
        {
            wlan_cli_config_vars[num_elements - 1].get(core, cli);
        }
        return;
    }

    struct mmagic_cli_config_elem *elem = mmagic_cli_element_search(wlan_cli_config_vars,
                                                                    num_elements, config_var);
    if (elem == NULL)
    {
        mmagic_cli_printf(cli, "Unable to find config variable 'wlan.%s'", config_var);
        return;
    }

    if (elem->get == NULL)
    {
        embeddedCliPrint(cli, "Unable to find getter");
        return;
    }

    if (elem->get(core, cli))
    {
        embeddedCliPrint(cli, "Get function failed");
    }
}

void mmagic_cli_wlan_set(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var,
                         const char *val)
{
    struct mmagic_data *core = &ctx->core;

    uint32_t num_elements = sizeof(wlan_cli_config_vars) / sizeof(wlan_cli_config_vars[0]);

    struct mmagic_cli_config_elem *elem = mmagic_cli_element_search(wlan_cli_config_vars,
                                                                    num_elements, config_var);
    if (elem == NULL)
    {
        mmagic_cli_printf(cli, "Unable to find config variable 'wlan.%s'", config_var);
        return;
    }

    if (elem->set == NULL)
    {
        embeddedCliPrint(cli, "Unable to find setter");
        return;
    }

    if (elem->set(core, cli, val))
    {
        mmagic_cli_printf(cli, "Set wlan.%s failed", elem->name);
    }
}

/********* Persistence *******/
void mmagic_cli_wlan_commit(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var)
{
    if ((config_var != NULL) && strcmp("all", config_var))
    {
        embeddedCliPrint(cli, "Unexpected argument! Only \'wlan\' or \'wlan.all\' supported.");
        return;
    }

    mmagic_core_wlan_save_all(&ctx->core);
    embeddedCliPrint(cli, "Successfully committed 'wlan' variables");
}

void mmagic_cli_wlan_load(struct mmagic_cli *ctx, EmbeddedCli *cli)
{
    MM_UNUSED(cli);
    mmagic_core_wlan_load_all(&ctx->core);
}

/********* CLI Command Handlers **********/

void mmagic_cli_wlan_connect(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_disconnect(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_scan(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_get_rssi(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_get_mac_addr(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_wnm_sleep(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_beacon_monitor_enable(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_beacon_monitor_disable(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_standby_enter(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_standby_exit(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_standby_set_status_payload(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_standby_set_wake_filter(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_standby_set_config(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_wlan_get_sta_status(EmbeddedCli *cli, char *args, void *context);

/********* Register bindings function definition **********/
void mmagic_cli_wlan_register_bindings(EmbeddedCli *cli, struct mmagic_data *core)
{
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-connect",
        "Brings up the WLAN interface and connects to the AP with configured parameters.",
        true,
        core,
        mmagic_cli_wlan_connect
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-disconnect",
        "Disconnects and brings down the WLAN interface.",
        true,
        core,
        mmagic_cli_wlan_disconnect
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-scan",
        "Starts an undirected scan for available networks.",
        true,
        core,
        mmagic_cli_wlan_scan
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-get_rssi",
        "Retrieves the RSSI if the WLAN interface is up, else 0.",
        true,
        core,
        mmagic_cli_wlan_get_rssi
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-get_mac_addr",
        "Retrieves the MAC address if the WLAN interface is up.",
        true,
        core,
        mmagic_cli_wlan_get_mac_addr
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-wnm_sleep",
        "Requests entry or exit from extended sleep (wnm sleep) if the WLAN interface is up.",
        true,
        core,
        mmagic_cli_wlan_wnm_sleep
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-beacon_monitor_enable",
        "Enable beacon monitoring with the given filter settings. If beacon monitoring is already enabled it will be reconfigured with the given arguments.",
        true,
        core,
        mmagic_cli_wlan_beacon_monitor_enable
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-beacon_monitor_disable",
        "Disable beacon monitoring. If beacon monitor is not enabled then this has no effect.",
        true,
        core,
        mmagic_cli_wlan_beacon_monitor_disable
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_enter",
        "This puts the Morse chip into standby mode allowing the host processor to go to sleep while the Morse chip takes over certain functionality to keep the connection alive with the provision to wake up the host processor when certain conditions are met.",
        true,
        core,
        mmagic_cli_wlan_standby_enter
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_exit",
        "Forces the Morse chip to exit standby mode. There may be certain instances such as a timer expiry, which cause the host chip to wake up independant of the Morse chip. In such situations, the host calls this function to instruct the Morse chip to exit standby mode and return to normal operating mode.",
        true,
        core,
        mmagic_cli_wlan_standby_exit
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_set_status_payload",
        "Sets the user payload for the standby status packet. Once standby mode is enabled, the Morse chip will periodically emit a UDP standby status packet regardless of whether it is in standby or not. The UDP packet will also be sent immediately upon entering or exiting Standby mode. If this command is not executed then the standby status packet will contain no payload.",
        true,
        core,
        mmagic_cli_wlan_standby_set_status_payload
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_set_wake_filter",
        "Configures the standby mode UDP wake packet filter. The system can be woken up from standby mode by sending it a UDP wake packet. If a wake filter is set using this function then the wake packet will only wake up the system if the specified filter pattern matches the payload at the specified offset within the payload. If this command is not executed then any wake packet will wake up the system.",
        true,
        core,
        mmagic_cli_wlan_standby_set_wake_filter
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-standby_set_config",
        "Sets the standby mode configuration parameters. If this command is not executed then the defaults are as specified.",
        true,
        core,
        mmagic_cli_wlan_standby_set_config
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "wlan-get_sta_status",
        "Retrieves the STA status of the WLAN interface.",
        true,
        core,
        mmagic_cli_wlan_get_sta_status
    });
}

void mmagic_cli_wlan_init(struct mmagic_cli *ctx)
{
    /* Register Commands */
    mmagic_cli_wlan_register_bindings(ctx->cli, &ctx->core);

    /* Register config variable accessor functions */
    struct mmagic_cli_config_accessor *accessor =
        (struct mmagic_cli_config_accessor *)mmosal_malloc(sizeof(*accessor));
    MMOSAL_ASSERT(accessor);

    mmosal_safer_strcpy(accessor->name, "wlan", sizeof(accessor->name));
    accessor->get = mmagic_cli_wlan_get;
    accessor->set = mmagic_cli_wlan_set;
    accessor->commit = mmagic_cli_wlan_commit;
    accessor->next = NULL;

    mmagic_cli_register_config_accessor(ctx, accessor);
}
