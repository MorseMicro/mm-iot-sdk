/*
 * Copyright 2025 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 *
 * Note: The corresponding headers files must be included BEFORE this def file. Additionally this
 *       file should only be in one (and only one) compilation unit (.c/.cpp file).
 */
#include <ctype.h>

#include "mmconfig.h"
#include "mmutils.h"
#include "cli/mmagic_cli.h"
#include "cli/autogen/mmagic_cli_internal.h"

/*
 * The fixed width that the key will be padded to, with trailing spaces, before the value is
 * printed.
 */
#define KEY_NAME_PADDING 32

/********* Getters **********/

int mmagic_cli_ip_get_ip_addr(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);
    const char *key_name = "ip.ip_addr";
    MM_STATIC_ASSERT((sizeof("ip.ip_addr") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_struct_ip_addr_to_string(&data->config.ip_addr,
                                              &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_ip_get_netmask(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);
    const char *key_name = "ip.netmask";
    MM_STATIC_ASSERT((sizeof("ip.netmask") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_struct_ip_addr_to_string(&data->config.netmask,
                                              &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_ip_get_gateway(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);
    const char *key_name = "ip.gateway";
    MM_STATIC_ASSERT((sizeof("ip.gateway") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_struct_ip_addr_to_string(&data->config.gateway,
                                              &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_ip_get_dns_server0(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);
    const char *key_name = "ip.dns_server0";
    MM_STATIC_ASSERT((sizeof("ip.dns_server0") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_struct_ip_addr_to_string(&data->config.dns_server0,
                                              &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_ip_get_dns_server1(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);
    const char *key_name = "ip.dns_server1";
    MM_STATIC_ASSERT((sizeof("ip.dns_server1") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_struct_ip_addr_to_string(&data->config.dns_server1,
                                              &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_ip_get_dhcp_enabled(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);
    const char *key_name = "ip.dhcp_enabled";
    MM_STATIC_ASSERT((sizeof("ip.dhcp_enabled") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.dhcp_enabled,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_ip_get_dhcp_offload(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);
    const char *key_name = "ip.dhcp_offload";
    MM_STATIC_ASSERT((sizeof("ip.dhcp_offload") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.dhcp_offload,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

int mmagic_cli_ip_get_link_status_evt_en(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);
    const char *key_name = "ip.link_status_evt_en";
    MM_STATIC_ASSERT((sizeof("ip.link_status_evt_en") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;
    written = mmagic_bool_to_string(data->config.link_status_evt_en,
                                    &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}

/********* Setters **********/

int mmagic_cli_ip_set_ip_addr(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);

    if (mmagic_string_to_struct_ip_addr(&data->config.ip_addr, val))
    {
        return -1;
    }

    mmagic_cli_ip_get_ip_addr(core, cli);

    return 0;
}

int mmagic_cli_ip_set_netmask(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);

    if (mmagic_string_to_struct_ip_addr(&data->config.netmask, val))
    {
        return -1;
    }

    mmagic_cli_ip_get_netmask(core, cli);

    return 0;
}

int mmagic_cli_ip_set_gateway(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);

    if (mmagic_string_to_struct_ip_addr(&data->config.gateway, val))
    {
        return -1;
    }

    mmagic_cli_ip_get_gateway(core, cli);

    return 0;
}

int mmagic_cli_ip_set_dns_server0(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);

    if (mmagic_string_to_struct_ip_addr(&data->config.dns_server0, val))
    {
        return -1;
    }

    mmagic_cli_ip_get_dns_server0(core, cli);

    return 0;
}

int mmagic_cli_ip_set_dns_server1(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);

    if (mmagic_string_to_struct_ip_addr(&data->config.dns_server1, val))
    {
        return -1;
    }

    mmagic_cli_ip_get_dns_server1(core, cli);

    return 0;
}

int mmagic_cli_ip_set_dhcp_enabled(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);

    if (mmagic_string_to_bool(&data->config.dhcp_enabled, val))
    {
        return -1;
    }

    mmagic_cli_ip_get_dhcp_enabled(core, cli);

    return 0;
}

int mmagic_cli_ip_set_dhcp_offload(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);

    if (mmagic_string_to_bool(&data->config.dhcp_offload, val))
    {
        return -1;
    }

    mmagic_cli_ip_get_dhcp_offload(core, cli);

    return 0;
}

int mmagic_cli_ip_set_link_status_evt_en(struct mmagic_data *core, EmbeddedCli *cli,
                                         const char *val)
{
    struct mmagic_ip_data *data = mmagic_data_get_ip(core);

    if (mmagic_string_to_bool(&data->config.link_status_evt_en, val))
    {
        return -1;
    }

    mmagic_cli_ip_get_link_status_evt_en(core, cli);

    return 0;
}

/********* Dictionary **********
 *
 * This list must be in alphabetical order as @c mmagic_cli_element_search() is implemented using
 * a binary search which requires an ordered list.
 */
struct mmagic_cli_config_elem ip_cli_config_vars[] = {
    {"dhcp_enabled", mmagic_cli_ip_get_dhcp_enabled, mmagic_cli_ip_set_dhcp_enabled},
    {"dhcp_offload", mmagic_cli_ip_get_dhcp_offload, mmagic_cli_ip_set_dhcp_offload},
    {"dns_server0", mmagic_cli_ip_get_dns_server0, mmagic_cli_ip_set_dns_server0},
    {"dns_server1", mmagic_cli_ip_get_dns_server1, mmagic_cli_ip_set_dns_server1},
    {"gateway", mmagic_cli_ip_get_gateway, mmagic_cli_ip_set_gateway},
    {"ip_addr", mmagic_cli_ip_get_ip_addr, mmagic_cli_ip_set_ip_addr},
    {"link_status_evt_en", mmagic_cli_ip_get_link_status_evt_en,
     mmagic_cli_ip_set_link_status_evt_en},
    {"netmask", mmagic_cli_ip_get_netmask, mmagic_cli_ip_set_netmask},
};

/********* IP Configuration Getter/Setter Handlers **********/
void mmagic_cli_ip_get(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var)
{
    struct mmagic_data *core = &ctx->core;

    if (config_var == NULL)
    {
        embeddedCliPrint(cli, "Invalid argument");
        return;
    }

    uint32_t num_elements = sizeof(ip_cli_config_vars) / sizeof(ip_cli_config_vars[0]);

    if (!strcmp("all", config_var))
    {
        for (; num_elements > 0; num_elements--)
        {
            ip_cli_config_vars[num_elements - 1].get(core, cli);
        }
        return;
    }

    struct mmagic_cli_config_elem *elem = mmagic_cli_element_search(ip_cli_config_vars,
                                                                    num_elements, config_var);
    if (elem == NULL)
    {
        mmagic_cli_printf(cli, "Unable to find config variable 'ip.%s'", config_var);
        return;
    }

    if (elem->get == NULL)
    {
        embeddedCliPrint(cli, "Unable to find getter");
        return;
    }

    if (elem->get(core, cli))
    {
        embeddedCliPrint(cli, "Get function failed");
    }
}

void mmagic_cli_ip_set(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var,
                       const char *val)
{
    struct mmagic_data *core = &ctx->core;

    uint32_t num_elements = sizeof(ip_cli_config_vars) / sizeof(ip_cli_config_vars[0]);

    struct mmagic_cli_config_elem *elem = mmagic_cli_element_search(ip_cli_config_vars,
                                                                    num_elements, config_var);
    if (elem == NULL)
    {
        mmagic_cli_printf(cli, "Unable to find config variable 'ip.%s'", config_var);
        return;
    }

    if (elem->set == NULL)
    {
        embeddedCliPrint(cli, "Unable to find setter");
        return;
    }

    if (elem->set(core, cli, val))
    {
        mmagic_cli_printf(cli, "Set ip.%s failed", elem->name);
    }
}

/********* Persistence *******/
void mmagic_cli_ip_commit(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var)
{
    if ((config_var != NULL) && strcmp("all", config_var))
    {
        embeddedCliPrint(cli, "Unexpected argument! Only \'ip\' or \'ip.all\' supported.");
        return;
    }

    mmagic_core_ip_save_all(&ctx->core);
    embeddedCliPrint(cli, "Successfully committed 'ip' variables");
}

void mmagic_cli_ip_load(struct mmagic_cli *ctx, EmbeddedCli *cli)
{
    MM_UNUSED(cli);
    mmagic_core_ip_load_all(&ctx->core);
}

/********* CLI Command Handlers **********/

void mmagic_cli_ip_status(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_ip_reload(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_ip_enable_tcp_keepalive_offload(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_ip_disable_tcp_keepalive_offload(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_ip_set_whitelist_filter(EmbeddedCli *cli, char *args, void *context);

void mmagic_cli_ip_clear_whitelist_filter(EmbeddedCli *cli, char *args, void *context);

/********* Register bindings function definition **********/
void mmagic_cli_ip_register_bindings(EmbeddedCli *cli, struct mmagic_data *core)
{
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "ip-status",
        "Gets the status of the IP stack.",
        true,
        core,
        mmagic_cli_ip_status
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "ip-reload",
        "Reloads the IP stack network configuration based on the current values in the subsystem config.",
        true,
        core,
        mmagic_cli_ip_reload
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "ip-enable_tcp_keepalive_offload",
        "Enables sending periodic TCP keep-alive packets by the morse chip allowing the TCP connection to be maintained without waking up the host processor. This needs to be enabled before opening a TCP connection. As of now, this feature will work only on the first TCP connection opened after this command.",
        true,
        core,
        mmagic_cli_ip_enable_tcp_keepalive_offload
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "ip-disable_tcp_keepalive_offload",
        "Disables sending of TCP keepalive packets.",
        true,
        core,
        mmagic_cli_ip_disable_tcp_keepalive_offload
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "ip-set_whitelist_filter",
        "Sets the whitelist filter specifing which incoming packets can wake the system from standby mode.",
        true,
        core,
        mmagic_cli_ip_set_whitelist_filter
    });

    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "ip-clear_whitelist_filter",
        "Clears any applied whitelist filters.",
        true,
        core,
        mmagic_cli_ip_clear_whitelist_filter
    });
}

void mmagic_cli_ip_init(struct mmagic_cli *ctx)
{
    /* Register Commands */
    mmagic_cli_ip_register_bindings(ctx->cli, &ctx->core);

    /* Register config variable accessor functions */
    struct mmagic_cli_config_accessor *accessor =
        (struct mmagic_cli_config_accessor *)mmosal_malloc(sizeof(*accessor));
    MMOSAL_ASSERT(accessor);

    mmosal_safer_strcpy(accessor->name, "ip", sizeof(accessor->name));
    accessor->get = mmagic_cli_ip_get;
    accessor->set = mmagic_cli_ip_set;
    accessor->commit = mmagic_cli_ip_commit;
    accessor->next = NULL;

    mmagic_cli_register_config_accessor(ctx, accessor);
}
