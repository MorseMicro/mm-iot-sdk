/*
 * Copyright 2024 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#include "mmagic_core_types.h"
#include "mmosal.h"

/* --------------------  types -------------------- */

static const struct enum_security_type_string_lut
{
    const char *string_value;
    enum mmagic_security_type enum_value;
} enum_security_type_string_lut[] = {
    {
        .string_value = "sae",
        .enum_value = MMAGIC_SECURITY_TYPE_SAE,
    },
    {
        .string_value = "owe",
        .enum_value = MMAGIC_SECURITY_TYPE_OWE,
    },
    {
        .string_value = "open",
        .enum_value = MMAGIC_SECURITY_TYPE_OPEN,
    },
};

int mmagic_enum_security_type_to_string(enum mmagic_security_type value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0;
         ii < (sizeof(enum_security_type_string_lut) / sizeof(enum_security_type_string_lut[0]));
         ii++)
    {
        if (enum_security_type_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_security_type_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_security_type(enum mmagic_security_type *value, const char *buf)
{
    size_t ii;
    for (ii = 0;
         ii < (sizeof(enum_security_type_string_lut) / sizeof(enum_security_type_string_lut[0]));
         ii++)
    {
        if (strcasecmp(buf, enum_security_type_string_lut[ii].string_value) == 0)
        {
            *value = enum_security_type_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_pmf_mode_string_lut
{
    const char *string_value;
    enum mmagic_pmf_mode enum_value;
} enum_pmf_mode_string_lut[] = {
    {
        .string_value = "required",
        .enum_value = MMAGIC_PMF_MODE_REQUIRED,
    },
    {
        .string_value = "disabled",
        .enum_value = MMAGIC_PMF_MODE_DISABLED,
    },
};

int mmagic_enum_pmf_mode_to_string(enum mmagic_pmf_mode value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0; ii < (sizeof(enum_pmf_mode_string_lut) / sizeof(enum_pmf_mode_string_lut[0]));
         ii++)
    {
        if (enum_pmf_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_pmf_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_pmf_mode(enum mmagic_pmf_mode *value, const char *buf)
{
    size_t ii;
    for (ii = 0; ii < (sizeof(enum_pmf_mode_string_lut) / sizeof(enum_pmf_mode_string_lut[0]));
         ii++)
    {
        if (strcasecmp(buf, enum_pmf_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_pmf_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_power_save_mode_string_lut
{
    const char *string_value;
    enum mmagic_power_save_mode enum_value;
} enum_power_save_mode_string_lut[] = {
    {
        .string_value = "disabled",
        .enum_value = MMAGIC_POWER_SAVE_MODE_DISABLED,
    },
    {
        .string_value = "enabled",
        .enum_value = MMAGIC_POWER_SAVE_MODE_ENABLED,
    },
};

int mmagic_enum_power_save_mode_to_string(enum mmagic_power_save_mode value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0;
         ii <
         (sizeof(enum_power_save_mode_string_lut) / sizeof(enum_power_save_mode_string_lut[0]));
         ii++)
    {
        if (enum_power_save_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_power_save_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_power_save_mode(enum mmagic_power_save_mode *value, const char *buf)
{
    size_t ii;
    for (ii = 0;
         ii <
         (sizeof(enum_power_save_mode_string_lut) / sizeof(enum_power_save_mode_string_lut[0]));
         ii++)
    {
        if (strcasecmp(buf, enum_power_save_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_power_save_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_station_type_string_lut
{
    const char *string_value;
    enum mmagic_station_type enum_value;
} enum_station_type_string_lut[] = {
    {
        .string_value = "sensor",
        .enum_value = MMAGIC_STATION_TYPE_SENSOR,
    },
    {
        .string_value = "non_sensor",
        .enum_value = MMAGIC_STATION_TYPE_NON_SENSOR,
    },
};

int mmagic_enum_station_type_to_string(enum mmagic_station_type value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0;
         ii < (sizeof(enum_station_type_string_lut) / sizeof(enum_station_type_string_lut[0]));
         ii++)
    {
        if (enum_station_type_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_station_type_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_station_type(enum mmagic_station_type *value, const char *buf)
{
    size_t ii;
    for (ii = 0;
         ii < (sizeof(enum_station_type_string_lut) / sizeof(enum_station_type_string_lut[0]));
         ii++)
    {
        if (strcasecmp(buf, enum_station_type_string_lut[ii].string_value) == 0)
        {
            *value = enum_station_type_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_status_string_lut
{
    const char *string_value;
    enum mmagic_status enum_value;
} enum_status_string_lut[] = {
    {
        .string_value = "ok",
        .enum_value = MMAGIC_STATUS_OK,
    },
    {
        .string_value = "error",
        .enum_value = MMAGIC_STATUS_ERROR,
    },
    {
        .string_value = "invalid_arg",
        .enum_value = MMAGIC_STATUS_INVALID_ARG,
    },
    {
        .string_value = "unavailable",
        .enum_value = MMAGIC_STATUS_UNAVAILABLE,
    },
    {
        .string_value = "timeout",
        .enum_value = MMAGIC_STATUS_TIMEOUT,
    },
    {
        .string_value = "invalid_stream",
        .enum_value = MMAGIC_STATUS_INVALID_STREAM,
    },
    {
        .string_value = "not_found",
        .enum_value = MMAGIC_STATUS_NOT_FOUND,
    },
    {
        .string_value = "not_supported",
        .enum_value = MMAGIC_STATUS_NOT_SUPPORTED,
    },
    {
        .string_value = "tx_error",
        .enum_value = MMAGIC_STATUS_TX_ERROR,
    },
    {
        .string_value = "no_mem",
        .enum_value = MMAGIC_STATUS_NO_MEM,
    },
    {
        .string_value = "closed",
        .enum_value = MMAGIC_STATUS_CLOSED,
    },
    {
        .string_value = "channel_list_not_set",
        .enum_value = MMAGIC_STATUS_CHANNEL_LIST_NOT_SET,
    },
    {
        .string_value = "shutdown_blocked",
        .enum_value = MMAGIC_STATUS_SHUTDOWN_BLOCKED,
    },
    {
        .string_value = "channel_invalid",
        .enum_value = MMAGIC_STATUS_CHANNEL_INVALID,
    },
    {
        .string_value = "not_running",
        .enum_value = MMAGIC_STATUS_NOT_RUNNING,
    },
    {
        .string_value = "no_link",
        .enum_value = MMAGIC_STATUS_NO_LINK,
    },
    {
        .string_value = "unknown_host",
        .enum_value = MMAGIC_STATUS_UNKNOWN_HOST,
    },
    {
        .string_value = "socket_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_FAILED,
    },
    {
        .string_value = "socket_connect_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_CONNECT_FAILED,
    },
    {
        .string_value = "socket_bind_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_BIND_FAILED,
    },
    {
        .string_value = "socket_listen_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_LISTEN_FAILED,
    },
};

int mmagic_enum_status_to_string(enum mmagic_status value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0; ii < (sizeof(enum_status_string_lut) / sizeof(enum_status_string_lut[0])); ii++)
    {
        if (enum_status_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_status_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_status(enum mmagic_status *value, const char *buf)
{
    size_t ii;
    for (ii = 0; ii < (sizeof(enum_status_string_lut) / sizeof(enum_status_string_lut[0])); ii++)
    {
        if (strcasecmp(buf, enum_status_string_lut[ii].string_value) == 0)
        {
            *value = enum_status_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_iperf_mode_string_lut
{
    const char *string_value;
    enum mmagic_iperf_mode enum_value;
} enum_iperf_mode_string_lut[] = {
    {
        .string_value = "udp_server",
        .enum_value = MMAGIC_IPERF_MODE_UDP_SERVER,
    },
    {
        .string_value = "tcp_server",
        .enum_value = MMAGIC_IPERF_MODE_TCP_SERVER,
    },
    {
        .string_value = "udp_client",
        .enum_value = MMAGIC_IPERF_MODE_UDP_CLIENT,
    },
    {
        .string_value = "tcp_client",
        .enum_value = MMAGIC_IPERF_MODE_TCP_CLIENT,
    },
};

int mmagic_enum_iperf_mode_to_string(enum mmagic_iperf_mode value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0; ii < (sizeof(enum_iperf_mode_string_lut) / sizeof(enum_iperf_mode_string_lut[0]));
         ii++)
    {
        if (enum_iperf_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_iperf_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_iperf_mode(enum mmagic_iperf_mode *value, const char *buf)
{
    size_t ii;
    for (ii = 0; ii < (sizeof(enum_iperf_mode_string_lut) / sizeof(enum_iperf_mode_string_lut[0]));
         ii++)
    {
        if (strcasecmp(buf, enum_iperf_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_iperf_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_iperf_state_string_lut
{
    const char *string_value;
    enum mmagic_iperf_state enum_value;
} enum_iperf_state_string_lut[] = {
    {
        .string_value = "not_started",
        .enum_value = MMAGIC_IPERF_STATE_NOT_STARTED,
    },
    {
        .string_value = "running",
        .enum_value = MMAGIC_IPERF_STATE_RUNNING,
    },
    {
        .string_value = "finished",
        .enum_value = MMAGIC_IPERF_STATE_FINISHED,
    },
    {
        .string_value = "aborted",
        .enum_value = MMAGIC_IPERF_STATE_ABORTED,
    },
};

int mmagic_enum_iperf_state_to_string(enum mmagic_iperf_state value, char *buf, size_t len)
{
    size_t ii;
    for (ii =
             0; ii < (sizeof(enum_iperf_state_string_lut) / sizeof(enum_iperf_state_string_lut[0]));
         ii++)
    {
        if (enum_iperf_state_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_iperf_state_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_iperf_state(enum mmagic_iperf_state *value, const char *buf)
{
    size_t ii;
    for (ii =
             0; ii < (sizeof(enum_iperf_state_string_lut) / sizeof(enum_iperf_state_string_lut[0]));
         ii++)
    {
        if (strcasecmp(buf, enum_iperf_state_string_lut[ii].string_value) == 0)
        {
            *value = enum_iperf_state_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_ip_link_state_string_lut
{
    const char *string_value;
    enum mmagic_ip_link_state enum_value;
} enum_ip_link_state_string_lut[] = {
    {
        .string_value = "down",
        .enum_value = MMAGIC_IP_LINK_STATE_DOWN,
    },
    {
        .string_value = "up",
        .enum_value = MMAGIC_IP_LINK_STATE_UP,
    },
};

int mmagic_enum_ip_link_state_to_string(enum mmagic_ip_link_state value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0;
         ii < (sizeof(enum_ip_link_state_string_lut) / sizeof(enum_ip_link_state_string_lut[0]));
         ii++)
    {
        if (enum_ip_link_state_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_ip_link_state_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_ip_link_state(enum mmagic_ip_link_state *value, const char *buf)
{
    size_t ii;
    for (ii = 0;
         ii < (sizeof(enum_ip_link_state_string_lut) / sizeof(enum_ip_link_state_string_lut[0]));
         ii++)
    {
        if (strcasecmp(buf, enum_ip_link_state_string_lut[ii].string_value) == 0)
        {
            *value = enum_ip_link_state_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_deep_sleep_mode_string_lut
{
    const char *string_value;
    enum mmagic_deep_sleep_mode enum_value;
} enum_deep_sleep_mode_string_lut[] = {
    {
        .string_value = "disabled",
        .enum_value = MMAGIC_DEEP_SLEEP_MODE_DISABLED,
    },
    {
        .string_value = "one_shot",
        .enum_value = MMAGIC_DEEP_SLEEP_MODE_ONE_SHOT,
    },
    {
        .string_value = "hardware",
        .enum_value = MMAGIC_DEEP_SLEEP_MODE_HARDWARE,
    },
};

int mmagic_enum_deep_sleep_mode_to_string(enum mmagic_deep_sleep_mode value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0;
         ii <
         (sizeof(enum_deep_sleep_mode_string_lut) / sizeof(enum_deep_sleep_mode_string_lut[0]));
         ii++)
    {
        if (enum_deep_sleep_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_deep_sleep_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_deep_sleep_mode(enum mmagic_deep_sleep_mode *value, const char *buf)
{
    size_t ii;
    for (ii = 0;
         ii <
         (sizeof(enum_deep_sleep_mode_string_lut) / sizeof(enum_deep_sleep_mode_string_lut[0]));
         ii++)
    {
        if (strcasecmp(buf, enum_deep_sleep_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_deep_sleep_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_standby_mode_exit_reason_string_lut
{
    const char *string_value;
    enum mmagic_standby_mode_exit_reason enum_value;
} enum_standby_mode_exit_reason_string_lut[] = {
    {
        .string_value = "standby_exit_none",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_NONE,
    },
    {
        .string_value = "standby_exit_wakeup_frame",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_WAKEUP_FRAME,
    },
    {
        .string_value = "standby_exit_associate",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_ASSOCIATE,
    },
    {
        .string_value = "standby_exit_ext_input",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_EXT_INPUT,
    },
    {
        .string_value = "standby_exit_whitelist_pkt",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_WHITELIST_PKT,
    },
    {
        .string_value = "standby_exit_tcp_connection_lost",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_TCP_CONNECTION_LOST,
    },
    {
        .string_value = "standby_exit_hw_scan_not_enabled",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_HW_SCAN_NOT_ENABLED,
    },
    {
        .string_value = "standby_exit_hw_scan_failed_to_start",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_HW_SCAN_FAILED_TO_START,
    },
};

int mmagic_enum_standby_mode_exit_reason_to_string(enum mmagic_standby_mode_exit_reason value,
                                                   char *buf, size_t len)
{
    size_t ii;
    for (ii =
             0;
         ii <
         (sizeof(enum_standby_mode_exit_reason_string_lut) /
          sizeof(enum_standby_mode_exit_reason_string_lut[0])); ii++)
    {
        if (enum_standby_mode_exit_reason_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s",
                            enum_standby_mode_exit_reason_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_standby_mode_exit_reason(enum mmagic_standby_mode_exit_reason *value,
                                                   const char *buf)
{
    size_t ii;
    for (ii =
             0;
         ii <
         (sizeof(enum_standby_mode_exit_reason_string_lut) /
          sizeof(enum_standby_mode_exit_reason_string_lut[0])); ii++)
    {
        if (strcasecmp(buf, enum_standby_mode_exit_reason_string_lut[ii].string_value) == 0)
        {
            *value = enum_standby_mode_exit_reason_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

/* -------------------- Basic types -------------------- */

int mmagic_bool_to_string(bool value, char *buf, size_t len)
{
    return snprintf(buf, len, "%s", value ? "true" : "false");
}

int mmagic_string_to_bool(bool *value, const char *buf)
{
    if (strcasecmp("true", buf) == 0)
    {
        *value = true;
        return 0;
    }
    else if (strcasecmp("false", buf) == 0)
    {
        *value = false;
        return 0;
    }

    return -1;
}

int mmagic_uint16_t_to_string(uint16_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%u", value);
}

int mmagic_string_to_uint16_t(uint16_t *value, const char *buf)
{
    int32_t parsed_val = strtoul(buf, NULL, 10);
    if (parsed_val < 0 || parsed_val > UINT16_MAX)
    {
        return -1;
    }
    *value = (uint16_t)parsed_val;
    return 0;
}

int mmagic_int16_t_to_string(int16_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%d", value);
}

int mmagic_string_to_int16_t(int16_t *value, const char *buf)
{
    int parsed_val = strtol(buf, NULL, 10);
    if (parsed_val < 0 || parsed_val > INT16_MAX || parsed_val < INT16_MIN)
    {
        return -1;
    }
    *value = (int16_t)parsed_val;
    return 0;
}

int mmagic_uint32_t_to_string(uint32_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%lu", value);
}

int mmagic_string_to_uint32_t(uint32_t *value, const char *buf)
{
    int parsed_val = strtoul(buf, NULL, 10);
    if (parsed_val < 0)
    {
        return parsed_val;
    }
    *value = (uint32_t)parsed_val;
    return 0;
}

int mmagic_int32_t_to_string(int32_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%ld", value);
}

int mmagic_string_to_int32_t(int32_t *value, const char *buf)
{
    int32_t parsed_val = strtol(buf, NULL, 10);
    *value = (int32_t)parsed_val;
    return 0;
}

/* -------------------- Struct types -------------------- */

int mmagic_struct_country_code_to_string(const struct struct_country_code *value, char *buf,
                                         size_t len)
{
    return snprintf(buf, len, "%.*s", 2, value->country_code);
}

int mmagic_string_to_struct_country_code(struct struct_country_code *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->country_code));
    if (len > sizeof(value->country_code) - 1)
    {
        return -1;
    }

    strncpy((char *)value->country_code, buf, len);

    return 0;
}

int mmagic_struct_ip_addr_to_string(const struct struct_ip_addr *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", strnlen(value->addr, sizeof(value->addr)), value->addr);
}

int mmagic_string_to_struct_ip_addr(struct struct_ip_addr *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->addr));
    if (len > sizeof(value->addr) - 1)
    {
        return -1;
    }

    strncpy((char *)value->addr, buf, len);
    /* Set the last character to terminate the string */
    value->addr[len] = 0;

    return 0;
}

int mmagic_struct_mac_addr_to_string(const struct struct_mac_addr *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%02x:%02x:%02x:%02x:%02x:%02x",
                    value->addr[0], value->addr[1], value->addr[2],
                    value->addr[3], value->addr[4], value->addr[5]);
}

int mmagic_string_to_struct_mac_addr(struct struct_mac_addr *value, const char *buf)
{
    /* Need to provide an array of ints to sscanf otherwise it will overflow */
    int temp[6];
    int i;

    int ret = sscanf(buf, "%x:%x:%x:%x:%x:%x",
                     &temp[0], &temp[1], &temp[2],
                     &temp[3], &temp[4], &temp[5]);
    if (ret != 6)
    {
        return -1;
    }

    for (i = 0; i < 6; i++)
    {
        if (temp[i] > UINT8_MAX || temp[i] < 0)
        {
            return -1;
        }

        value->addr[i] = (uint8_t)temp[i];
    }

    return 0;
}

int mmagic_struct_string_32_to_string(const struct struct_string_32 *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", (int)value->len, value->data);
}

int mmagic_string_to_struct_string_32(struct struct_string_32 *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->data));
    if (len > sizeof(value->data) - 1)
    {
        return -1;
    }

    strncpy((char *)value->data, buf, len);
    value->len = len;

    return 0;
}
