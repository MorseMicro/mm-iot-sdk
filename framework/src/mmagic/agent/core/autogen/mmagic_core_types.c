/*
 * Copyright 2025 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#include "mmagic_core_types.h"
#include "mmosal.h"

/* --------------------  types -------------------- */

static const struct enum_security_type_string_lut
{
    const char *string_value;
    enum mmagic_security_type enum_value;
} enum_security_type_string_lut[] = {
    {
        .string_value = "sae",
        .enum_value = MMAGIC_SECURITY_TYPE_SAE,
    },
    {
        .string_value = "owe",
        .enum_value = MMAGIC_SECURITY_TYPE_OWE,
    },
    {
        .string_value = "open",
        .enum_value = MMAGIC_SECURITY_TYPE_OPEN,
    },
};

int mmagic_enum_security_type_to_string(enum mmagic_security_type value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_security_type_string_lut); ii++)
    {
        if (enum_security_type_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_security_type_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_security_type(enum mmagic_security_type *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_security_type_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_security_type_string_lut[ii].string_value) == 0)
        {
            *value = enum_security_type_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_pmf_mode_string_lut
{
    const char *string_value;
    enum mmagic_pmf_mode enum_value;
} enum_pmf_mode_string_lut[] = {
    {
        .string_value = "required",
        .enum_value = MMAGIC_PMF_MODE_REQUIRED,
    },
    {
        .string_value = "disabled",
        .enum_value = MMAGIC_PMF_MODE_DISABLED,
    },
};

int mmagic_enum_pmf_mode_to_string(enum mmagic_pmf_mode value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_pmf_mode_string_lut); ii++)
    {
        if (enum_pmf_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_pmf_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_pmf_mode(enum mmagic_pmf_mode *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_pmf_mode_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_pmf_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_pmf_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_power_save_mode_string_lut
{
    const char *string_value;
    enum mmagic_power_save_mode enum_value;
} enum_power_save_mode_string_lut[] = {
    {
        .string_value = "disabled",
        .enum_value = MMAGIC_POWER_SAVE_MODE_DISABLED,
    },
    {
        .string_value = "enabled",
        .enum_value = MMAGIC_POWER_SAVE_MODE_ENABLED,
    },
};

int mmagic_enum_power_save_mode_to_string(enum mmagic_power_save_mode value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_power_save_mode_string_lut); ii++)
    {
        if (enum_power_save_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_power_save_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_power_save_mode(enum mmagic_power_save_mode *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_power_save_mode_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_power_save_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_power_save_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_mcs10_mode_string_lut
{
    const char *string_value;
    enum mmagic_mcs10_mode enum_value;
} enum_mcs10_mode_string_lut[] = {
    {
        .string_value = "disabled",
        .enum_value = MMAGIC_MCS10_MODE_DISABLED,
    },
    {
        .string_value = "forced",
        .enum_value = MMAGIC_MCS10_MODE_FORCED,
    },
    {
        .string_value = "auto",
        .enum_value = MMAGIC_MCS10_MODE_AUTO,
    },
};

int mmagic_enum_mcs10_mode_to_string(enum mmagic_mcs10_mode value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_mcs10_mode_string_lut); ii++)
    {
        if (enum_mcs10_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_mcs10_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_mcs10_mode(enum mmagic_mcs10_mode *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_mcs10_mode_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_mcs10_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_mcs10_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_duty_cycle_mode_string_lut
{
    const char *string_value;
    enum mmagic_duty_cycle_mode enum_value;
} enum_duty_cycle_mode_string_lut[] = {
    {
        .string_value = "spread",
        .enum_value = MMAGIC_DUTY_CYCLE_MODE_SPREAD,
    },
    {
        .string_value = "burst",
        .enum_value = MMAGIC_DUTY_CYCLE_MODE_BURST,
    },
};

int mmagic_enum_duty_cycle_mode_to_string(enum mmagic_duty_cycle_mode value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_duty_cycle_mode_string_lut); ii++)
    {
        if (enum_duty_cycle_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_duty_cycle_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_duty_cycle_mode(enum mmagic_duty_cycle_mode *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_duty_cycle_mode_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_duty_cycle_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_duty_cycle_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_station_type_string_lut
{
    const char *string_value;
    enum mmagic_station_type enum_value;
} enum_station_type_string_lut[] = {
    {
        .string_value = "sensor",
        .enum_value = MMAGIC_STATION_TYPE_SENSOR,
    },
    {
        .string_value = "non_sensor",
        .enum_value = MMAGIC_STATION_TYPE_NON_SENSOR,
    },
};

int mmagic_enum_station_type_to_string(enum mmagic_station_type value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_station_type_string_lut); ii++)
    {
        if (enum_station_type_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_station_type_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_station_type(enum mmagic_station_type *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_station_type_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_station_type_string_lut[ii].string_value) == 0)
        {
            *value = enum_station_type_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_status_string_lut
{
    const char *string_value;
    enum mmagic_status enum_value;
} enum_status_string_lut[] = {
    {
        .string_value = "ok",
        .enum_value = MMAGIC_STATUS_OK,
    },
    {
        .string_value = "error",
        .enum_value = MMAGIC_STATUS_ERROR,
    },
    {
        .string_value = "invalid_arg",
        .enum_value = MMAGIC_STATUS_INVALID_ARG,
    },
    {
        .string_value = "unavailable",
        .enum_value = MMAGIC_STATUS_UNAVAILABLE,
    },
    {
        .string_value = "timeout",
        .enum_value = MMAGIC_STATUS_TIMEOUT,
    },
    {
        .string_value = "invalid_stream",
        .enum_value = MMAGIC_STATUS_INVALID_STREAM,
    },
    {
        .string_value = "not_found",
        .enum_value = MMAGIC_STATUS_NOT_FOUND,
    },
    {
        .string_value = "not_supported",
        .enum_value = MMAGIC_STATUS_NOT_SUPPORTED,
    },
    {
        .string_value = "tx_error",
        .enum_value = MMAGIC_STATUS_TX_ERROR,
    },
    {
        .string_value = "no_mem",
        .enum_value = MMAGIC_STATUS_NO_MEM,
    },
    {
        .string_value = "closed",
        .enum_value = MMAGIC_STATUS_CLOSED,
    },
    {
        .string_value = "channel_list_not_set",
        .enum_value = MMAGIC_STATUS_CHANNEL_LIST_NOT_SET,
    },
    {
        .string_value = "shutdown_blocked",
        .enum_value = MMAGIC_STATUS_SHUTDOWN_BLOCKED,
    },
    {
        .string_value = "channel_invalid",
        .enum_value = MMAGIC_STATUS_CHANNEL_INVALID,
    },
    {
        .string_value = "not_running",
        .enum_value = MMAGIC_STATUS_NOT_RUNNING,
    },
    {
        .string_value = "no_link",
        .enum_value = MMAGIC_STATUS_NO_LINK,
    },
    {
        .string_value = "unknown_host",
        .enum_value = MMAGIC_STATUS_UNKNOWN_HOST,
    },
    {
        .string_value = "socket_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_FAILED,
    },
    {
        .string_value = "socket_connect_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_CONNECT_FAILED,
    },
    {
        .string_value = "socket_bind_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_BIND_FAILED,
    },
    {
        .string_value = "socket_listen_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_LISTEN_FAILED,
    },
    {
        .string_value = "ntp_kod_received",
        .enum_value = MMAGIC_STATUS_NTP_KOD_RECEIVED,
    },
    {
        .string_value = "ntp_kod_backoff_received",
        .enum_value = MMAGIC_STATUS_NTP_KOD_BACKOFF_RECEIVED,
    },
    {
        .string_value = "socket_send_failed",
        .enum_value = MMAGIC_STATUS_SOCKET_SEND_FAILED,
    },
    {
        .string_value = "invalid_credentials",
        .enum_value = MMAGIC_STATUS_INVALID_CREDENTIALS,
    },
    {
        .string_value = "handshake_failed",
        .enum_value = MMAGIC_STATUS_HANDSHAKE_FAILED,
    },
    {
        .string_value = "authentication_failed",
        .enum_value = MMAGIC_STATUS_AUTHENTICATION_FAILED,
    },
    {
        .string_value = "missing_credentials",
        .enum_value = MMAGIC_STATUS_MISSING_CREDENTIALS,
    },
    {
        .string_value = "time_not_synchronized",
        .enum_value = MMAGIC_STATUS_TIME_NOT_SYNCHRONIZED,
    },
    {
        .string_value = "mqtt_refused",
        .enum_value = MMAGIC_STATUS_MQTT_REFUSED,
    },
    {
        .string_value = "mqtt_keepalive_timeout",
        .enum_value = MMAGIC_STATUS_MQTT_KEEPALIVE_TIMEOUT,
    },
    {
        .string_value = "bad_version",
        .enum_value = MMAGIC_STATUS_BAD_VERSION,
    },
};

int mmagic_enum_status_to_string(enum mmagic_status value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_status_string_lut); ii++)
    {
        if (enum_status_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_status_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_status(enum mmagic_status *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_status_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_status_string_lut[ii].string_value) == 0)
        {
            *value = enum_status_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_iperf_mode_string_lut
{
    const char *string_value;
    enum mmagic_iperf_mode enum_value;
} enum_iperf_mode_string_lut[] = {
    {
        .string_value = "udp_server",
        .enum_value = MMAGIC_IPERF_MODE_UDP_SERVER,
    },
    {
        .string_value = "tcp_server",
        .enum_value = MMAGIC_IPERF_MODE_TCP_SERVER,
    },
    {
        .string_value = "udp_client",
        .enum_value = MMAGIC_IPERF_MODE_UDP_CLIENT,
    },
    {
        .string_value = "tcp_client",
        .enum_value = MMAGIC_IPERF_MODE_TCP_CLIENT,
    },
};

int mmagic_enum_iperf_mode_to_string(enum mmagic_iperf_mode value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_iperf_mode_string_lut); ii++)
    {
        if (enum_iperf_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_iperf_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_iperf_mode(enum mmagic_iperf_mode *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_iperf_mode_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_iperf_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_iperf_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_iperf_state_string_lut
{
    const char *string_value;
    enum mmagic_iperf_state enum_value;
} enum_iperf_state_string_lut[] = {
    {
        .string_value = "not_started",
        .enum_value = MMAGIC_IPERF_STATE_NOT_STARTED,
    },
    {
        .string_value = "running",
        .enum_value = MMAGIC_IPERF_STATE_RUNNING,
    },
    {
        .string_value = "finished",
        .enum_value = MMAGIC_IPERF_STATE_FINISHED,
    },
    {
        .string_value = "aborted",
        .enum_value = MMAGIC_IPERF_STATE_ABORTED,
    },
};

int mmagic_enum_iperf_state_to_string(enum mmagic_iperf_state value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_iperf_state_string_lut); ii++)
    {
        if (enum_iperf_state_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_iperf_state_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_iperf_state(enum mmagic_iperf_state *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_iperf_state_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_iperf_state_string_lut[ii].string_value) == 0)
        {
            *value = enum_iperf_state_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_ip_link_state_string_lut
{
    const char *string_value;
    enum mmagic_ip_link_state enum_value;
} enum_ip_link_state_string_lut[] = {
    {
        .string_value = "down",
        .enum_value = MMAGIC_IP_LINK_STATE_DOWN,
    },
    {
        .string_value = "up",
        .enum_value = MMAGIC_IP_LINK_STATE_UP,
    },
};

int mmagic_enum_ip_link_state_to_string(enum mmagic_ip_link_state value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_ip_link_state_string_lut); ii++)
    {
        if (enum_ip_link_state_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_ip_link_state_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_ip_link_state(enum mmagic_ip_link_state *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_ip_link_state_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_ip_link_state_string_lut[ii].string_value) == 0)
        {
            *value = enum_ip_link_state_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_deep_sleep_mode_string_lut
{
    const char *string_value;
    enum mmagic_deep_sleep_mode enum_value;
} enum_deep_sleep_mode_string_lut[] = {
    {
        .string_value = "disabled",
        .enum_value = MMAGIC_DEEP_SLEEP_MODE_DISABLED,
    },
    {
        .string_value = "one_shot",
        .enum_value = MMAGIC_DEEP_SLEEP_MODE_ONE_SHOT,
    },
    {
        .string_value = "hardware",
        .enum_value = MMAGIC_DEEP_SLEEP_MODE_HARDWARE,
    },
};

int mmagic_enum_deep_sleep_mode_to_string(enum mmagic_deep_sleep_mode value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_deep_sleep_mode_string_lut); ii++)
    {
        if (enum_deep_sleep_mode_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_deep_sleep_mode_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_deep_sleep_mode(enum mmagic_deep_sleep_mode *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_deep_sleep_mode_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_deep_sleep_mode_string_lut[ii].string_value) == 0)
        {
            *value = enum_deep_sleep_mode_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_standby_mode_exit_reason_string_lut
{
    const char *string_value;
    enum mmagic_standby_mode_exit_reason enum_value;
} enum_standby_mode_exit_reason_string_lut[] = {
    {
        .string_value = "standby_exit_none",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_NONE,
    },
    {
        .string_value = "standby_exit_wakeup_frame",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_WAKEUP_FRAME,
    },
    {
        .string_value = "standby_exit_associate",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_ASSOCIATE,
    },
    {
        .string_value = "standby_exit_ext_input",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_EXT_INPUT,
    },
    {
        .string_value = "standby_exit_whitelist_pkt",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_WHITELIST_PKT,
    },
    {
        .string_value = "standby_exit_tcp_connection_lost",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_TCP_CONNECTION_LOST,
    },
    {
        .string_value = "standby_exit_hw_scan_not_enabled",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_HW_SCAN_NOT_ENABLED,
    },
    {
        .string_value = "standby_exit_hw_scan_failed_to_start",
        .enum_value = MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_HW_SCAN_FAILED_TO_START,
    },
};

int mmagic_enum_standby_mode_exit_reason_to_string(enum mmagic_standby_mode_exit_reason value,
                                                   char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_standby_mode_exit_reason_string_lut); ii++)
    {
        if (enum_standby_mode_exit_reason_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s",
                            enum_standby_mode_exit_reason_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_standby_mode_exit_reason(enum mmagic_standby_mode_exit_reason *value,
                                                   const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_standby_mode_exit_reason_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_standby_mode_exit_reason_string_lut[ii].string_value) == 0)
        {
            *value = enum_standby_mode_exit_reason_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_sta_state_string_lut
{
    const char *string_value;
    enum mmagic_sta_state enum_value;
} enum_sta_state_string_lut[] = {
    {
        .string_value = "disconnected",
        .enum_value = MMAGIC_STA_STATE_DISCONNECTED,
    },
    {
        .string_value = "connecting",
        .enum_value = MMAGIC_STA_STATE_CONNECTING,
    },
    {
        .string_value = "connected",
        .enum_value = MMAGIC_STA_STATE_CONNECTED,
    },
};

int mmagic_enum_sta_state_to_string(enum mmagic_sta_state value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_sta_state_string_lut); ii++)
    {
        if (enum_sta_state_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_sta_state_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_sta_state(enum mmagic_sta_state *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_sta_state_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_sta_state_string_lut[ii].string_value) == 0)
        {
            *value = enum_sta_state_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

static const struct enum_sta_event_string_lut
{
    const char *string_value;
    enum mmagic_sta_event enum_value;
} enum_sta_event_string_lut[] = {
    {
        .string_value = "scan_request",
        .enum_value = MMAGIC_STA_EVENT_SCAN_REQUEST,
    },
    {
        .string_value = "scan_complete",
        .enum_value = MMAGIC_STA_EVENT_SCAN_COMPLETE,
    },
    {
        .string_value = "scan_abort",
        .enum_value = MMAGIC_STA_EVENT_SCAN_ABORT,
    },
    {
        .string_value = "auth_request",
        .enum_value = MMAGIC_STA_EVENT_AUTH_REQUEST,
    },
    {
        .string_value = "assoc_request",
        .enum_value = MMAGIC_STA_EVENT_ASSOC_REQUEST,
    },
    {
        .string_value = "deauth_tx",
        .enum_value = MMAGIC_STA_EVENT_DEAUTH_TX,
    },
    {
        .string_value = "ctrl_port_open",
        .enum_value = MMAGIC_STA_EVENT_CTRL_PORT_OPEN,
    },
    {
        .string_value = "ctrl_port_closed",
        .enum_value = MMAGIC_STA_EVENT_CTRL_PORT_CLOSED,
    },
};

int mmagic_enum_sta_event_to_string(enum mmagic_sta_event value, char *buf, size_t len)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_sta_event_string_lut); ii++)
    {
        if (enum_sta_event_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", enum_sta_event_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_enum_sta_event(enum mmagic_sta_event *value, const char *buf)
{
    for (size_t ii = 0; ii < MM_ARRAY_COUNT(enum_sta_event_string_lut); ii++)
    {
        if (strcasecmp(buf, enum_sta_event_string_lut[ii].string_value) == 0)
        {
            *value = enum_sta_event_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}

/* -------------------- Basic types -------------------- */

int mmagic_bool_to_string(bool value, char *buf, size_t len)
{
    return snprintf(buf, len, "%s", value ? "true" : "false");
}

int mmagic_string_to_bool(bool *value, const char *buf)
{
    if (strcasecmp("true", buf) == 0)
    {
        *value = true;
        return 0;
    }
    else if (strcasecmp("false", buf) == 0)
    {
        *value = false;
        return 0;
    }

    return -1;
}

int mmagic_uint16_t_to_string(uint16_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%u", value);
}

int mmagic_string_to_uint16_t(uint16_t *value, const char *buf)
{
    int32_t parsed_val = strtoul(buf, NULL, 10);
    if (parsed_val < 0 || parsed_val > UINT16_MAX)
    {
        return -1;
    }
    *value = (uint16_t)parsed_val;
    return 0;
}

int mmagic_int16_t_to_string(int16_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%d", value);
}

int mmagic_string_to_int16_t(int16_t *value, const char *buf)
{
    int parsed_val = strtol(buf, NULL, 10);
    if (parsed_val < 0 || parsed_val > INT16_MAX || parsed_val < INT16_MIN)
    {
        return -1;
    }
    *value = (int16_t)parsed_val;
    return 0;
}

int mmagic_uint32_t_to_string(uint32_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%lu", value);
}

int mmagic_string_to_uint32_t(uint32_t *value, const char *buf)
{
    int parsed_val = strtoul(buf, NULL, 10);
    if (parsed_val < 0)
    {
        return parsed_val;
    }
    *value = (uint32_t)parsed_val;
    return 0;
}

int mmagic_int32_t_to_string(int32_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%ld", value);
}

int mmagic_string_to_int32_t(int32_t *value, const char *buf)
{
    int32_t parsed_val = strtol(buf, NULL, 10);
    *value = (int32_t)parsed_val;
    return 0;
}

/* -------------------- String types -------------------- */

int mmagic_string32_to_string(const struct string32 *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", (int)value->len, value->data);
}

int mmagic_string_to_string32(struct string32 *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->data));
    if (len > sizeof(value->data) - 1)
    {
        return -1;
    }

    mmosal_safer_strcpy((char *)value->data, buf, len + 1);
    value->len = len;

    return 0;
}

int mmagic_string100_to_string(const struct string100 *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", (int)value->len, value->data);
}

int mmagic_string_to_string100(struct string100 *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->data));
    if (len > sizeof(value->data) - 1)
    {
        return -1;
    }

    mmosal_safer_strcpy((char *)value->data, buf, len + 1);
    value->len = len;

    return 0;
}

int mmagic_string254_to_string(const struct string254 *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", (int)value->len, value->data);
}

int mmagic_string_to_string254(struct string254 *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->data));
    if (len > sizeof(value->data) - 1)
    {
        return -1;
    }

    mmosal_safer_strcpy((char *)value->data, buf, len + 1);
    value->len = len;

    return 0;
}

/* -------------------- Struct types -------------------- */

int mmagic_struct_country_code_to_string(const struct struct_country_code *value, char *buf,
                                         size_t len)
{
    return snprintf(buf, len, "%.*s", 2, value->country_code);
}

int mmagic_string_to_struct_country_code(struct struct_country_code *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->country_code));
    if (len > sizeof(value->country_code) - 1)
    {
        return -1;
    }

    mmosal_safer_strcpy((char *)value->country_code, buf, len + 1);

    return 0;
}

int mmagic_struct_ip_addr_to_string(const struct struct_ip_addr *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", strnlen(value->addr, sizeof(value->addr)), value->addr);
}

int mmagic_string_to_struct_ip_addr(struct struct_ip_addr *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->addr));
    if (len > sizeof(value->addr) - 1)
    {
        return -1;
    }

    mmosal_safer_strcpy((char *)value->addr, buf, len + 1);

    return 0;
}

int mmagic_struct_mac_addr_to_string(const struct struct_mac_addr *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%02x:%02x:%02x:%02x:%02x:%02x",
                    value->addr[0], value->addr[1], value->addr[2],
                    value->addr[3], value->addr[4], value->addr[5]);
}

int mmagic_string_to_struct_mac_addr(struct struct_mac_addr *value, const char *buf)
{
    /* Need to provide an array of ints to sscanf otherwise it will overflow */
    int temp[6];
    int i;

    int ret = sscanf(buf, "%x:%x:%x:%x:%x:%x",
                     &temp[0], &temp[1], &temp[2],
                     &temp[3], &temp[4], &temp[5]);
    if (ret != 6)
    {
        return -1;
    }

    for (i = 0; i < 6; i++)
    {
        if (temp[i] > UINT8_MAX || temp[i] < 0)
        {
            return -1;
        }

        value->addr[i] = (uint8_t)temp[i];
    }

    return 0;
}
