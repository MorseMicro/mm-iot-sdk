/*
 * Copyright 2024 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#pragma once

#include "mmagic_core_types.h"

struct mmagic_data;

struct mmagic_wlan_config
{
    /** Boolean value indicating whether AMPDU support should be enabled. */
    bool ampdu_enabled;
    /** BSSID of the ap to associate to, all 0x00 for any. */
    struct struct_mac_addr bssid;
    /** Whether Centralized Authentication Controlled is enabled on the STA. */
    bool cac_enabled;
    /** Two character country code used to identify the regulatory domain. */
    struct struct_country_code country_code;
    /** Sets the 802.11 fragmentation threshold. The fragmentation threshold (in octets)
     * to set, or 0 to disable. */
    uint32_t fragment_threshold;
    /** The maximum interval to wait after the last health check before triggering
     * another. If this parameter is 0 then periodic health checks will be disabled.
     * min_interval_ms must always be less than or equal to max_interval_ms. Set this
     * to UINT32_MAX to have the maximum unbounded. If only max_health_check_intvl_ms
     * is specified, then min_health_check_intvl_ms is assumed to be 0. */
    uint32_t max_health_check_intvl_ms;
    /** The minimum interval to wait after the last health check before triggering
     * another. If this parameter is 0 then health checks will always happen at the
     * max_interval_ms value. min_interval_ms must always be less than or equal to
     * max_interval_ms. If only min_health_check_intvl_ms is specified, then
     * max_health_check_intvl_ms is assumed to be unbounded. */
    uint32_t min_health_check_intvl_ms;
    /** If non zero, enables ARP refresh offload with the specified interval in seconds.
     * Note: ARP response offload needs to be enabled for this feature to work. */
    uint32_t offload_arp_refresh_s;
    /** If true, enables ARP response offload which allows the Morse chip to directly
     * respond to ARP requests without waking up the host processor. */
    bool offload_arp_response;
    /** Password used when associating, 1-32 characters long. */
    struct struct_string_32 password;
    /** Protected Management Frame mode to use (802.11w) */
    enum mmagic_pmf_mode pmf_mode;
    /** Sets the 802.11 power save mode. */
    enum mmagic_power_save_mode power_save_mode;
    /** Priority to request if raw is supported by the AP. Valid priorities are 0-7. -1
     * disables RAW. */
    int16_t raw_priority;
    /** The RTS threshold (in octets) to set, or 0 to disable. */
    uint32_t rts_threshold;
    /** Security type to used when associating. */
    enum mmagic_security_type security;
    /** Boolean value indicating whether SGI support should be enabled. */
    bool sgi_enabled;
    /** SSID of the AP to connect to, can be 1-32 characters long. */
    struct struct_string_32 ssid;
    /** S1G non-AP STA type. */
    enum mmagic_station_type station_type;
    /** Boolean value indicating whether sub-band support should be enabled. */
    bool subbands_enabled;
};

struct mmagic_wlan_data
{
    struct mmagic_wlan_config config;
};

/**
 * Function to initialize the core data structure and register the ops functions.
 *
 * @param core Reference to to global mmagic context struct.
 */
void mmagic_core_wlan_init(struct mmagic_data *core);

/**
 * Function to load settings from persistent store for the core wlan subsystem.
 *
 * @param core Reference to to global mmagic context struct.
 */
void mmagic_core_wlan_load_all(struct mmagic_data *core);

/**
 * Function to save settings to persistent store for the core wlan subsystem.
 *
 * @param core Reference to to global mmagic context struct.
 */
void mmagic_core_wlan_save_all(struct mmagic_data *core);

/**
 * Function to start any of the core processes for the core wlan subsystem.
 *
 * @param core Reference to to global mmagic context struct.
 */
void mmagic_core_wlan_start(struct mmagic_data *core);

/** Command arguments structure for wlan_connect */
struct MM_PACKED mmagic_core_wlan_connect_cmd_args
{
    uint32_t timeout;
};

enum mmagic_status mmagic_core_wlan_connect(
    struct mmagic_data *core,
    const struct mmagic_core_wlan_connect_cmd_args *cmd_args);

enum mmagic_status mmagic_core_wlan_disconnect(
    struct mmagic_data *core);

/** Command arguments structure for wlan_scan */
struct MM_PACKED mmagic_core_wlan_scan_cmd_args
{
    uint32_t timeout;
};

/** Response arguments structure for wlan_scan */
struct MM_PACKED mmagic_core_wlan_scan_rsp_args
{
    struct struct_scan_status results;
};

enum mmagic_status mmagic_core_wlan_scan(
    struct mmagic_data *core,
    const struct mmagic_core_wlan_scan_cmd_args *cmd_args,
    struct mmagic_core_wlan_scan_rsp_args *rsp_args);

/** Response arguments structure for wlan_get_rssi */
struct MM_PACKED mmagic_core_wlan_get_rssi_rsp_args
{
    int32_t rssi;
};

enum mmagic_status mmagic_core_wlan_get_rssi(
    struct mmagic_data *core,
    struct mmagic_core_wlan_get_rssi_rsp_args *rsp_args);

/** Response arguments structure for wlan_get_mac_addr */
struct MM_PACKED mmagic_core_wlan_get_mac_addr_rsp_args
{
    struct struct_mac_addr mac_addr;
};

enum mmagic_status mmagic_core_wlan_get_mac_addr(
    struct mmagic_data *core,
    struct mmagic_core_wlan_get_mac_addr_rsp_args *rsp_args);

/** Command arguments structure for wlan_wnm_sleep */
struct MM_PACKED mmagic_core_wlan_wnm_sleep_cmd_args
{
    bool wnm_sleep_enabled;
};

enum mmagic_status mmagic_core_wlan_wnm_sleep(
    struct mmagic_data *core,
    const struct mmagic_core_wlan_wnm_sleep_cmd_args *cmd_args);

/** Command arguments structure for wlan_beacon_monitor_enable */
struct MM_PACKED mmagic_core_wlan_beacon_monitor_enable_cmd_args
{
    struct struct_oui_list oui_filter;
};

enum mmagic_status mmagic_core_wlan_beacon_monitor_enable(
    struct mmagic_data *core,
    const struct mmagic_core_wlan_beacon_monitor_enable_cmd_args *cmd_args);

enum mmagic_status mmagic_core_wlan_beacon_monitor_disable(
    struct mmagic_data *core);

enum mmagic_status mmagic_core_wlan_standby_enter(
    struct mmagic_data *core);

enum mmagic_status mmagic_core_wlan_standby_exit(
    struct mmagic_data *core);

/** Command arguments structure for wlan_standby_set_status_payload */
struct MM_PACKED mmagic_core_wlan_standby_set_status_payload_cmd_args
{
    struct struct_buffer64 payload;
};

enum mmagic_status mmagic_core_wlan_standby_set_status_payload(
    struct mmagic_data *core,
    const struct mmagic_core_wlan_standby_set_status_payload_cmd_args *cmd_args);

/** Command arguments structure for wlan_standby_set_wake_filter */
struct MM_PACKED mmagic_core_wlan_standby_set_wake_filter_cmd_args
{
    struct struct_buffer64 filter;
    uint32_t offset;
};

enum mmagic_status mmagic_core_wlan_standby_set_wake_filter(
    struct mmagic_data *core,
    const struct mmagic_core_wlan_standby_set_wake_filter_cmd_args *cmd_args);

/** Command arguments structure for wlan_standby_set_config */
struct MM_PACKED mmagic_core_wlan_standby_set_config_cmd_args
{
    uint32_t notify_period_s;
    struct struct_ip_addr src_ip;
    struct struct_ip_addr dst_ip;
    uint16_t dst_port;
    uint32_t bss_inactivity_s;
    uint32_t snooze_period_s;
    uint32_t snooze_increment_s;
    uint32_t snooze_max_s;
};

enum mmagic_status mmagic_core_wlan_standby_set_config(
    struct mmagic_data *core,
    const struct mmagic_core_wlan_standby_set_config_cmd_args *cmd_args);
