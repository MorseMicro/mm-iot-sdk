/*
 * Copyright 2024 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#pragma once

/**
 * @ingroup MMAGIC
 * @defgroup MMAGIC_CONTROLLER Morse M2M Interface Controller API
 *
 * @{
 *
 * This module provides a small implementation of the Controller stack for integration with
 * application software. This code mostly stands alone from the rest of the Morse IoT SDK.
 *
 * To integrate the Controller code into your application:
 * * Copy the files in this directory into your application.
 * * Also copy `mmutils/mmutils.h`, `mmutils/mmbuf.h`, and `mmutils/mmbuf.c` into your application.
 * * Implement the APIs defined by `mmagic_datalink_controller.h` and `mmosal_controller.h`. (See
 *   the @c m2m_controller.c application as a reference.)
 * * Include mmagic_controller.h in your application to integrate the Controller functionality.
 */

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MM_PACKED
/** Macro for packed structs */
#define MM_PACKED __attribute__((packed))
#endif

/**
 * @defgroup MMAGIC_CONTROLLER_DATA_TYPES Data types
 *
 * @{
 */

/** Connection security type */
enum mmagic_security_type
{
    /** Simultaneous Authentication of Equals (password-based authentication) */
    MMAGIC_SECURITY_TYPE_SAE  = 0,
    /** Opportunistic Wireless Encryption (encrypted, passwordless) */
    MMAGIC_SECURITY_TYPE_OWE  = 1,
    /** No security enabled at all */
    MMAGIC_SECURITY_TYPE_OPEN = 2,
};

/** Protected management frame mode */
enum mmagic_pmf_mode
{
    /** Protected management frames must be used */
    MMAGIC_PMF_MODE_REQUIRED = 0,
    /** No protected management frames */
    MMAGIC_PMF_MODE_DISABLED = 1,
};

/** Enumeration of supported 802.11 power save modes. */
enum mmagic_power_save_mode
{
    /** Power save disabled. */
    MMAGIC_POWER_SAVE_MODE_DISABLED = 0,
    /** Power save enabled. */
    MMAGIC_POWER_SAVE_MODE_ENABLED  = 1,
};

/** Enumeration of S1G non-AP STA types. */
enum mmagic_station_type
{
    /** Sensor type. */
    MMAGIC_STATION_TYPE_SENSOR     = 0,
    /** Non-Sensor type. */
    MMAGIC_STATION_TYPE_NON_SENSOR = 1,
};

/** Enumeration of return status codes. */
enum mmagic_status
{
    /** Operation was successful. */
    MMAGIC_STATUS_OK             = 0,
    /** The operation failed with an unspecified error. */
    MMAGIC_STATUS_ERROR          = 1,
    /** The operation failed due to an invalid argument. */
    MMAGIC_STATUS_INVALID_ARG    = 2,
    /** Functionality is temporarily unavailable. */
    MMAGIC_STATUS_UNAVAILABLE    = 3,
    /** The operation failed due to an invalid argument. */
    MMAGIC_STATUS_TIMEOUT        = 4,
    /** An invalid stream was specified. */
    MMAGIC_STATUS_INVALID_STREAM = 5,
    /** Specified operation was not found. */
    MMAGIC_STATUS_NOT_FOUND      = 6,
    /** Specified operation is not supported. */
    MMAGIC_STATUS_NOT_SUPPORTED  = 7,
    /** An error occured during transmission. */
    MMAGIC_STATUS_TX_ERROR       = 8,
    /** Failed due to memory allocation failure. */
    MMAGIC_STATUS_NO_MEM         = 9,
    /** Failed due to stream being closed from the other side. */
    MMAGIC_STATUS_CLOSED         = 10,
    /** Maximum status value possible */
    MMAGIC_STATUS_MAX            = 11,
};

/** Mode to use when running the iperf. */
enum mmagic_iperf_mode
{
    /** Iperf UDP server (RX). */
    MMAGIC_IPERF_MODE_UDP_SERVER = 0,
    /** Iperf TCP server (RX). */
    MMAGIC_IPERF_MODE_TCP_SERVER = 1,
    /** Iperf UDP client (TX). */
    MMAGIC_IPERF_MODE_UDP_CLIENT = 2,
    /** Iperf TCP client (TX). */
    MMAGIC_IPERF_MODE_TCP_CLIENT = 3,
};

/** Current state of iperf session. */
enum mmagic_iperf_state
{
    /** Iperf session not started. */
    MMAGIC_IPERF_STATE_NOT_STARTED = 0,
    /** Iperf session is in progress. */
    MMAGIC_IPERF_STATE_RUNNING     = 1,
    /** Iperf session has completed. */
    MMAGIC_IPERF_STATE_FINISHED    = 2,
    /** Iperf session has been aborted. */
    MMAGIC_IPERF_STATE_ABORTED     = 3,
};

/** Status of the IP link. */
enum mmagic_ip_link_state
{
    /** Link is down because the interface is down or DHCP has not yet completed. */
    MMAGIC_IP_LINK_STATE_DOWN = 0,
    /** Link is up. This implies that the interface is up and DHCP has completed. */
    MMAGIC_IP_LINK_STATE_UP   = 1,
};

/** Deep sleep modes for the agent MCU. */
enum mmagic_deep_sleep_mode
{
    /** Deep sleep is disabled. */
    MMAGIC_DEEP_SLEEP_MODE_DISABLED = 0,
    /** Deep sleep is enabled until activity occurs on the datalink. */
    MMAGIC_DEEP_SLEEP_MODE_ONE_SHOT = 1,
    /** The datalink layer is responsible for waking the agent. */
    MMAGIC_DEEP_SLEEP_MODE_HARDWARE = 2,
};

/** Reasons for exiting standby mode. */
enum mmagic_standby_mode_exit_reason
{
    /** Standby mode was exited manually through a call to standby_exit. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_NONE                = 0,
    /** We were woken up by a wakeup frame. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_WAKEUP_FRAME        = 1,
    /** We just reassociated with the AP. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_ASSOCIATE           = 2,
    /** We were woken up by an external input trigger. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_EXT_INPUT           = 3,
    /** We received a packet from a whitelist source. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_WHITELIST_PKT       = 4,
    /** An open TCP connection was lost. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_TCP_CONNECTION_LOST = 5,
};

/** Packet buffer for standard 1536 byte size packets */
struct MM_PACKED struct_packet_buffer
{
    /** Length of the data in @c data */
    uint16_t len;
    /** Array containing the data */
    uint8_t data[1536];
};

/** Data type for string up to 254 characters (with space for a null terminating character). */
struct MM_PACKED struct_string_254
{
    /** Length of the data in @c data (excluding null terminator) */
    uint8_t len;
    /** Array containing the string */
    uint8_t data[255];
};

/** Data type for string up to 32 characters (with space for a null terminating character). */
struct MM_PACKED struct_string_32
{
    /** Length of the data in @c data (excluding null terminator) */
    uint8_t len;
    /** Array containing the string */
    uint8_t data[33];
};

/** Data type to contain mac address byte array */
struct MM_PACKED struct_mac_addr
{
    /** Array containing the mac addr */
    uint8_t addr[6];
};

/** Data type to contain Two character country code (null-terminated) used to identify the
 * regulatory domain. */
struct MM_PACKED struct_country_code
{
    /** Array containing the country code, including room for null-terminator. */
    char country_code[3];
};

/** Data type to contain a three octet OUI. */
struct MM_PACKED struct_oui
{
    /** The 3 octet OUI */
    uint8_t oui[3];
};

/** Data type to contain a list of three octet OUIs. */
struct MM_PACKED struct_oui_list
{
    /** The number of OUIs in the list. */
    uint8_t count;
    /** The OUI data. */
    struct struct_oui ouis[5];
};

/** Structure for holding a scan result. */
struct MM_PACKED struct_scan_result
{
    /** SSID of the AP. */
    struct struct_string_32 ssid;
    /** BSSID of the AP network. */
    struct struct_mac_addr bssid;
    /** RSSI of the AP in dBm. */
    int32_t rssi;
};

/** Structure for devise firmware and hardware versions. */
struct MM_PACKED struct_version_info
{
    /** Version of the application software. */
    struct struct_string_32 application_version;
    /** Version of the bootloader software. */
    struct struct_string_32 bootloader_version;
    /** Version of the user hardware. */
    struct struct_string_32 user_hardware_version;
    /** Version of the Morse firmware. */
    struct struct_string_32 morse_firmware_version;
    /** Version of the Morse IoT SDK library. */
    struct struct_string_32 morselib_version;
    /** Version of the Morse hardware. */
    struct struct_string_32 morse_hardware_version;
};

/** Structure for returning the scan status */
struct MM_PACKED struct_scan_status
{
    /** Array of scan results. */
    struct struct_scan_result results[10];
    /** Number of results retrieved */
    uint8_t num;
};

/** Data type for a string representation of an IP address. Dotted decimal notation for IPv4
 * addresses and colon-separated hexadecimal notation for IPv6 addresses. */
struct MM_PACKED struct_ip_addr
{
    /** Array containing the IP string */
    char addr[48];
};

/** Structure to contain the current IP status */
struct MM_PACKED struct_ip_status
{
    /** Current link state */
    enum mmagic_ip_link_state link_state;
    /** Whether or not dhcp is enabled */
    bool dhcp_enabled;
    /** Current IP address */
    struct struct_ip_addr ip_addr;
    /** Current IP network mask */
    struct struct_ip_addr netmask;
    /** Current IP gateway */
    struct struct_ip_addr gateway;
    /** Current broadcast IP address */
    struct struct_ip_addr broadcast;
    /** DNS server IP addresses */
    struct struct_ip_addr dns_servers[2];
};

/** Data structure to store ping results */
struct MM_PACKED struct_ping_status
{
    /** IP address of the device receiving the ping requests */
    struct struct_ip_addr receiver_addr;
    /** Total number of requests sent */
    uint32_t total_count;
    /** The number of ping responses received */
    uint32_t recv_count;
    /** The minimum latency in ms between request sent and response received */
    uint32_t min_time_ms;
    /** The average latency in ms between request sent and response received */
    uint32_t avg_time_ms;
    /** The maximum latency in ms between request sent and response received */
    uint32_t max_time_ms;
    /** Stores non-zero session ID whilst ping session is running */
    uint16_t session_id;
};

/** Data structure to store iperf results */
struct MM_PACKED struct_iperf_status
{
    /** IP address of the remote device */
    struct struct_ip_addr remote_addr;
    /** Port number of the remote device */
    uint16_t remote_port;
    /** IP address of the local device */
    struct struct_ip_addr local_addr;
    /** Port number of the local device */
    uint16_t local_port;
    /** The number of bytes of data transferred during the iperf test */
    uint64_t bytes_transferred;
    /** The duration of the iperf test in milliseconds */
    uint32_t duration_ms;
    /** The average throughput in kbps */
    uint32_t bandwidth_kbitpsec;
};

/** Generic 64 byte buffer */
struct MM_PACKED struct_buffer64
{
    /** The 64 byte buffer */
    uint8_t buffer[64];
    /** Leangth of data in the buffer */
    uint8_t len;
};

/**
 * Subsytem IDs
 */
enum mmagic_subsystem
{
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_WLAN */
    MMAGIC_WLAN  = 1,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_IP */
    MMAGIC_IP    = 2,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_PING */
    MMAGIC_PING  = 3,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_IPERF */
    MMAGIC_IPERF = 4,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_SYS */
    MMAGIC_SYS   = 5,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_TCP */
    MMAGIC_TCP   = 6,
};

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_INIT Initialization/deinitialization
 * @{
 */

/**
 * Controller struct used internally by the data-link. This will be specific to each
 * type of controller. i.e SPI and UART may have different elements in the struct.
 */
struct mmagic_controller;

/**
 * Prototype for callback function invoked whenever any time a event that the agent has
 * started is received.
 *
 * @note This callback will execute in the context of the Controller data link receive thread.
 *
 * @param controller Reference to the the controller handle.
 * @param arg        User argument that was given when the callback was registered.
 */
typedef void (*mmagic_controller_agent_start_cb_t)(struct mmagic_controller *controller, void *arg);

/**
 * Initialization structure for mmagic_controller.
 */
struct mmagic_controller_init_args
{
    /** Callback function to executed any time a event that the agent has started is received.*/
    mmagic_controller_agent_start_cb_t agent_start_cb;
    /** User argument that will be passed when the agent_start_cb is executed. */
    void *agent_start_arg;
};

/**
 * Initializer for @ref mmagic_controller_init_args.
 */
#define MMAGIC_CONTROLLER_ARGS_INIT { 0 }

/**
 * Initialize the Controller.
 *
 * @param  args Reference to the initialization arguments for the mmagic_controller.
 *              May be @c NULL, in which case default values will be used.
 *
 * @return      Reference to the created controller handle on success. @c Null on error.
 */
struct mmagic_controller *mmagic_controller_init(const struct mmagic_controller_init_args *args);

/**
 * Deinitialize the Controller. Any resources used will be freed.
 *
 * @param controller Reference to the controller handle.
 */
void mmagic_controller_deinit(struct mmagic_controller *controller);

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_INTERNAL Data types, etc., for internal use
 * @{
 *
 * Enumerations, etc., used by the underlying implementation, but which are not usually
 * needed to be used directly.
 */

/** The stream ID of the control stream */
#define CONTROL_STREAM  0

/**
 * Sends a command to the agent.
 *
 * @param  controller    A user context to be passed.
 * @param  stream_id     The stream id to send this command on.
 * @param  submodule_id  The submodule to target with this command.
 * @param  command_id    The command.
 * @param  subcommand_id A sub command or resource id if applicable.
 * @param  buffer        A pointer to any data associated with this command.
 *                       May be NULL if none.
 * @param  buffer_length Length of above data.
 *
 * @return               MMAGIC_STATUS_OK on success, else an error code.
 */
enum mmagic_status mmagic_controller_tx(
    struct mmagic_controller *controller, uint8_t stream_id,
    uint8_t submodule_id, uint8_t command_id, uint8_t subcommand_id,
    const uint8_t *buffer, size_t buffer_length);

/**
 * Waits for a response from the agent.
 *
 * @param  controller    Controller context.
 * @param  stream_id     The stream id to wait on.
 * @param  submodule_id  The submodule to wait on.
 * @param  command_id    The command to wait on.
 * @param  subcommand_id A sub command or resource id if applicable.
 * @param  buffer        A pointer to a buffer to load with any returned data.
 *                       May be NULL if none.
 * @param  buffer_length Length of above buffer.
 *
 * @return               MMAGIC_STATUS_OK on success, else an error code.
 */
enum mmagic_status mmagic_controller_rx(struct mmagic_controller *controller, uint8_t stream_id,
                                        uint8_t submodule_id,
                                        uint8_t command_id, uint8_t subcommand_id,
                                        uint8_t *buffer, size_t buffer_length);

/** wlan configuration variable IDs */
enum mmagic_wlan_var
{
    /** Boolean value indicating whether AMPDU support should be enabled. */
    MMAGIC_WLAN_VAR_AMPDU_ENABLED             = 0,
    /** BSSID of the ap to associate to, all 0x00 for any. */
    MMAGIC_WLAN_VAR_BSSID                     = 1,
    /** Whether Centralized Authentication Controlled is enabled on the STA. */
    MMAGIC_WLAN_VAR_CAC_ENABLED               = 2,
    /** Two character country code used to identify the regulatory domain. */
    MMAGIC_WLAN_VAR_COUNTRY_CODE              = 3,
    /** Sets the 802.11 fragmentation threshold. The fragmentation threshold (in octets) to set, or
     * 0 to disable. */
    MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD        = 4,
    /** The maximum interval to wait after the last health check before triggering another. If this
     * parameter is 0 then periodic health checks will be disabled. min_interval_ms must always be
     * less than or equal to max_interval_ms. Set this to UINT32_MAX to have the maximum unbounded.
     * If only max_health_check_intvl_ms is specified, then min_health_check_intvl_ms is assumed to
     * be 0. */
    MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS = 5,
    /** The minimum interval to wait after the last health check before triggering another. If this
     * parameter is 0 then health checks will always happen at the max_interval_ms value.
     * min_interval_ms must always be less than or equal to max_interval_ms. If only
     * min_health_check_intvl_ms is specified, then max_health_check_intvl_ms is assumed to be
     * unbounded. */
    MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS = 6,
    /** If non zero, enables ARP refresh offload with the specified interval in seconds. Note: ARP
     * response offload needs to be enabled for this feature to work. */
    MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S     = 7,
    /** If true, enables ARP response offload which allows the Morse chip to directly respond to ARP
     * requests without waking up the host processor. */
    MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE      = 8,
    /** Password used when associating, 1-32 characters long. */
    MMAGIC_WLAN_VAR_PASSWORD                  = 9,
    /** Protected Management Frame mode to use (802.11w) */
    MMAGIC_WLAN_VAR_PMF_MODE                  = 10,
    /** Sets the 802.11 power save mode. */
    MMAGIC_WLAN_VAR_POWER_SAVE_MODE           = 11,
    /** Priority to request if raw is supported by the AP. Valid priorities are 0-7. -1 disables
     * RAW. */
    MMAGIC_WLAN_VAR_RAW_PRIORITY              = 12,
    /** The RTS threshold (in octets) to set, or 0 to disable. */
    MMAGIC_WLAN_VAR_RTS_THRESHOLD             = 13,
    /** Security type to used when associating. */
    MMAGIC_WLAN_VAR_SECURITY                  = 14,
    /** Boolean value indicating whether SGI support should be enabled. */
    MMAGIC_WLAN_VAR_SGI_ENABLED               = 15,
    /** SSID of the AP to connect to, can be 1-32 characters long. */
    MMAGIC_WLAN_VAR_SSID                      = 16,
    /** S1G non-AP STA type. */
    MMAGIC_WLAN_VAR_STATION_TYPE              = 17,
    /** Boolean value indicating whether sub-band support should be enabled. */
    MMAGIC_WLAN_VAR_SUBBANDS_ENABLED          = 18,
};

/** wlan configuration command IDs */
enum mmagic_wlan_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_WLAN_CMD_GET                        = 0,
    /** Set the value of a configuration variable */
    MMAGIC_WLAN_CMD_SET                        = 1,
    /** Reserved (unused) */
    MMAGIC_WLAN_CMD_LOAD                       = 2,
    /** Commit the current configuration to flash */
    MMAGIC_WLAN_CMD_COMMIT                     = 3,
    /** Brings up the WLAN interface and connects to the AP with configured parameters. */
    MMAGIC_WLAN_CMD_CONNECT                    = 4,
    /** Disconnects and brings down the WLAN interface. */
    MMAGIC_WLAN_CMD_DISCONNECT                 = 5,
    /** Starts an undirected scan for available networks. */
    MMAGIC_WLAN_CMD_SCAN                       = 6,
    /** Retrieves the RSSI if the WLAN interface is up, else 0. */
    MMAGIC_WLAN_CMD_GET_RSSI                   = 7,
    /** Retrieves the MAC address if the WLAN interface is up. */
    MMAGIC_WLAN_CMD_GET_MAC_ADDR               = 8,
    /** Requests entry or exit from extended sleep (wnm sleep) if the WLAN interface is up. */
    MMAGIC_WLAN_CMD_WNM_SLEEP                  = 9,
    /** Enable beacon monitoring with the given filter settings. If beacon monitoring is already
     * enabled it will be reconfigured with the given arguments. */
    MMAGIC_WLAN_CMD_BEACON_MONITOR_ENABLE      = 10,
    /** Disable beacon monitoring. If beacon monitor is not enabled then this has no effect. */
    MMAGIC_WLAN_CMD_BEACON_MONITOR_DISABLE     = 11,
    /** This puts the Morse chip into standby mode allowing the host processor to go to sleep while
     * the Morse chip takes over certain functionality to keep the connection alive with the
     * provision to wake up the host processor when certain conditions are met. */
    MMAGIC_WLAN_CMD_STANDBY_ENTER              = 12,
    /** Forces the Morse chip to exit standby mode. There may be certain instances such as a timer
     * expiry, which cause the host chip to wake up independant of the Morse chip. In such
     * situations, the host calls this function to instruct the Morse chip to exit standby mode and
     * return to normal operating mode. */
    MMAGIC_WLAN_CMD_STANDBY_EXIT               = 13,
    /** Sets the user payload for the standby status packet. Once standby mode is enabled, the Morse
     * chip will periodically emit a UDP standby status packet regardless of whether it is in
     * standby or not. The UDP packet will also be sent immediately upon entering or exiting Standby
     * mode. If this command is not executed then the standby status packet will contain no payload.
     */
    MMAGIC_WLAN_CMD_STANDBY_SET_STATUS_PAYLOAD = 14,
    /** Configures the standby mode UDP wake packet filter. The system can be woken up from standby
     * mode by sending it a UDP wake packet. If a wake filter is set using this function then the
     * wake packet will only wake up the system if the specified filter pattern matches the payload
     * at the specified offset within the payload. If this command is not executed then any wake
     * packet will wake up the system. */
    MMAGIC_WLAN_CMD_STANDBY_SET_WAKE_FILTER    = 15,
    /** Sets the standby mode configuration parameters. If this command is not executed then the
     * defaults are as specified. */
    MMAGIC_WLAN_CMD_STANDBY_SET_CONFIG         = 16,
};

/** ip configuration variable IDs */
enum mmagic_ip_var
{
    /** True to enable DHCP for IP address configuration, or false to use the static configuration
     * given by ip_addr, netmask, and gateway. This will take effect when the reload command is
     * successfully executed. */
    MMAGIC_IP_VAR_DHCP_ENABLED = 0,
    /** If true, enables DHCP offload which allows the Morse chip to directly handle DHCP discovery
     * and leases without waking up the host processor. Note: this comes into effect only if
     * ip.dhcp_enabled is also true. */
    MMAGIC_IP_VAR_DHCP_OFFLOAD = 1,
    /** Primary DNS server IP address. If a value is specified this will override the primary DNS
     * server provided by DHCP (if any). Changes will take effect when the reload command is
     * successfully executed. */
    MMAGIC_IP_VAR_DNS_SERVER0  = 2,
    /** Secondary DNS server IP address. If a value is specified this will override the secondary
     * DNS server provided by DHCP (if any). Changes  will take effect when the reload command is
     * successfully executed. Note that this option may be ignored by some IP stacks. */
    MMAGIC_IP_VAR_DNS_SERVER1  = 3,
    /** Gateway to use for a static network connection. This will take effect when the reload
     * command is successfully executed. */
    MMAGIC_IP_VAR_GATEWAY      = 4,
    /** IP address to use for a static network connection. This will take effect when the reload
     * command is successfully executed. */
    MMAGIC_IP_VAR_IP_ADDR      = 5,
    /** Netmask to use for a static network connection. This will take effect when the reload
     * command is successfully executed. */
    MMAGIC_IP_VAR_NETMASK      = 6,
};

/** ip configuration command IDs */
enum mmagic_ip_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_IP_CMD_GET                           = 0,
    /** Set the value of a configuration variable */
    MMAGIC_IP_CMD_SET                           = 1,
    /** Reserved (unused) */
    MMAGIC_IP_CMD_LOAD                          = 2,
    /** Commit the current configuration to flash */
    MMAGIC_IP_CMD_COMMIT                        = 3,
    /** Gets the status of the IP stack. */
    MMAGIC_IP_CMD_STATUS                        = 4,
    /** Reloads the IP stack network configuration based on the current values in the subsystem
     * config. */
    MMAGIC_IP_CMD_RELOAD                        = 5,
    /** Enables sending periodic TCP keep-alive packets by the morse chip allowing the TCP
     * connection to be maintained without waking up the host processor. This needs to be enabled
     * before opening a TCP connection. As of now, this feature will work only on the first TCP
     * connection opened after this command. */
    MMAGIC_IP_CMD_ENABLE_TCP_KEEPALIVE_OFFLOAD  = 6,
    /** Disables sending of TCP keepalive packets. */
    MMAGIC_IP_CMD_DISABLE_TCP_KEEPALIVE_OFFLOAD = 7,
    /** Sets the whitelist filter specifing which incoming packets can wake the system from standby
     * mode. */
    MMAGIC_IP_CMD_SET_WHITELIST_FILTER          = 8,
    /** Clears any applied whitelist filters. */
    MMAGIC_IP_CMD_CLEAR_WHITELIST_FILTER        = 9,
};

/** ping configuration variable IDs */
enum mmagic_ping_var
{
    /** This specifies the number of ping requests to send before terminating the session. If this
     * is zero or exceeds UINT16_MAX (65535) then it it will be set to UINT16_MAX. */
    MMAGIC_PING_VAR_COUNT    = 0,
    /** The time interval between ping requests (in milliseconds). */
    MMAGIC_PING_VAR_INTERVAL = 1,
    /** The IP address of the ping target. */
    MMAGIC_PING_VAR_TARGET   = 2,
};

/** ping configuration command IDs */
enum mmagic_ping_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_PING_CMD_GET    = 0,
    /** Set the value of a configuration variable */
    MMAGIC_PING_CMD_SET    = 1,
    /** Reserved (unused) */
    MMAGIC_PING_CMD_LOAD   = 2,
    /** Commit the current configuration to flash */
    MMAGIC_PING_CMD_COMMIT = 3,
    /** Commences a ping session using the current values in the the subsystem config. */
    MMAGIC_PING_CMD_RUN    = 4,
};

/** iperf configuration variable IDs */
enum mmagic_iperf_var
{
    /** This specifies the duration for client transfers specified either in seconds or bytes. If
     * this is negative, it specifies a time in seconds; if positive, it specifies the number of
     * bytes to transmit. */
    MMAGIC_IPERF_VAR_AMOUNT = 0,
    /** The iperf mode to use. Valid values are udp_server, tcp_server, udp_client and tcp_client.
     * If not set, defaults to udp_server. */
    MMAGIC_IPERF_VAR_MODE   = 1,
    /** Specifies the local port to listen on when in server mode or the server port to send data to
     * when in client mode. */
    MMAGIC_IPERF_VAR_PORT   = 2,
    /** IP address of server to connect to when in client mode. */
    MMAGIC_IPERF_VAR_SERVER = 3,
};

/** iperf configuration command IDs */
enum mmagic_iperf_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_IPERF_CMD_GET    = 0,
    /** Set the value of a configuration variable */
    MMAGIC_IPERF_CMD_SET    = 1,
    /** Reserved (unused) */
    MMAGIC_IPERF_CMD_LOAD   = 2,
    /** Commit the current configuration to flash */
    MMAGIC_IPERF_CMD_COMMIT = 3,
    /** Starts an iperf session using the current values in the the subsystem config. */
    MMAGIC_IPERF_CMD_RUN    = 4,
};

/** sys configuration command IDs */
enum mmagic_sys_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_SYS_CMD_GET         = 0,
    /** Set the value of a configuration variable */
    MMAGIC_SYS_CMD_SET         = 1,
    /** Reserved (unused) */
    MMAGIC_SYS_CMD_LOAD        = 2,
    /** Commit the current configuration to flash */
    MMAGIC_SYS_CMD_COMMIT      = 3,
    /** Performs a soft reset. */
    MMAGIC_SYS_CMD_RESET       = 4,
    /** Enters deep sleep mode. */
    MMAGIC_SYS_CMD_DEEP_SLEEP  = 5,
    /** Gets the device firmware and hardware versions. */
    MMAGIC_SYS_CMD_GET_VERSION = 6,
};

/** tcp configuration command IDs */
enum mmagic_tcp_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_TCP_CMD_GET        = 0,
    /** Set the value of a configuration variable */
    MMAGIC_TCP_CMD_SET        = 1,
    /** Reserved (unused) */
    MMAGIC_TCP_CMD_LOAD       = 2,
    /** Commit the current configuration to flash */
    MMAGIC_TCP_CMD_COMMIT     = 3,
    /** Opens a client TCP socket and returns its stream ID */
    MMAGIC_TCP_CMD_CONNECT    = 4,
    /** Opens a server TCP socket and returns its stream ID */
    MMAGIC_TCP_CMD_BIND       = 5,
    /** Reads from a socket */
    MMAGIC_TCP_CMD_RECV       = 6,
    /** Writes to a socket */
    MMAGIC_TCP_CMD_SEND       = 7,
    /** Polls the socket till it is ready for reading */
    MMAGIC_TCP_CMD_READ_POLL  = 8,
    /** Polls the socket till it is ready for writing */
    MMAGIC_TCP_CMD_WRITE_POLL = 9,
    /** Waits for an incoming socket connection and returns a new stream ID. */
    MMAGIC_TCP_CMD_ACCEPT     = 10,
    /** Closes and frees the socket */
    MMAGIC_TCP_CMD_CLOSE      = 11,
};

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_WLAN Wireless LAN management subsystem (wlan)
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_WLAN_CONFIG wlan configuration variables
 * @{
 */

/**
 * Gets @c ampdu_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether AMPDU support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_ampdu_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_AMPDU_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_AMPDU_ENABLED, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c ampdu_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether AMPDU support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_ampdu_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_AMPDU_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_AMPDU_ENABLED, NULL, 0);
    return status;
}

/**
 * Gets @c bssid setting for module @c wlan.
 *
 * BSSID of the ap to associate to, all 0x00 for any.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_mac_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_bssid(
    struct mmagic_controller *controller, struct struct_mac_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_BSSID, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_BSSID, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c bssid setting for module @c wlan.
 *
 * BSSID of the ap to associate to, all 0x00 for any.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_mac_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_bssid(
    struct mmagic_controller *controller, struct struct_mac_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_BSSID, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_BSSID, NULL, 0);
    return status;
}

/**
 * Gets @c cac_enabled setting for module @c wlan.
 *
 * Whether Centralized Authentication Controlled is enabled on the STA.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_cac_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_CAC_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_CAC_ENABLED, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c cac_enabled setting for module @c wlan.
 *
 * Whether Centralized Authentication Controlled is enabled on the STA.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_cac_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_CAC_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_CAC_ENABLED, NULL, 0);
    return status;
}

/**
 * Gets @c country_code setting for module @c wlan.
 *
 * Two character country code used to identify the regulatory domain.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_country_code to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_country_code(
    struct mmagic_controller *controller, struct struct_country_code *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_COUNTRY_CODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_COUNTRY_CODE, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c country_code setting for module @c wlan.
 *
 * Two character country code used to identify the regulatory domain.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_country_code to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_country_code(
    struct mmagic_controller *controller, struct struct_country_code *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_COUNTRY_CODE, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_COUNTRY_CODE, NULL, 0);
    return status;
}

/**
 * Gets @c fragment_threshold setting for module @c wlan.
 *
 * Sets the 802.11 fragmentation threshold. The fragmentation threshold (in octets) to set, or 0 to
 * disable.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_fragment_threshold(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c fragment_threshold setting for module @c wlan.
 *
 * Sets the 802.11 fragmentation threshold. The fragmentation threshold (in octets) to set, or 0 to
 * disable.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_fragment_threshold(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD, NULL, 0);
    return status;
}

/**
 * Gets @c max_health_check_intvl_ms setting for module @c wlan.
 *
 * The maximum interval to wait after the last health check before triggering another. If this
 * parameter is 0 then periodic health checks will be disabled. min_interval_ms must always be less
 * than or equal to max_interval_ms. Set this to UINT32_MAX to have the maximum unbounded. If only
 * max_health_check_intvl_ms is specified, then min_health_check_intvl_ms is assumed to be 0.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_max_health_check_intvl_ms(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS, (uint8_t *)var,
                                  sizeof(*var));
    return status;
}

/**
 * Sets @c max_health_check_intvl_ms setting for module @c wlan.
 *
 * The maximum interval to wait after the last health check before triggering another. If this
 * parameter is 0 then periodic health checks will be disabled. min_interval_ms must always be less
 * than or equal to max_interval_ms. Set this to UINT32_MAX to have the maximum unbounded. If only
 * max_health_check_intvl_ms is specified, then min_health_check_intvl_ms is assumed to be 0.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_max_health_check_intvl_ms(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS, NULL, 0);
    return status;
}

/**
 * Gets @c min_health_check_intvl_ms setting for module @c wlan.
 *
 * The minimum interval to wait after the last health check before triggering another. If this
 * parameter is 0 then health checks will always happen at the max_interval_ms value.
 * min_interval_ms must always be less than or equal to max_interval_ms. If only
 * min_health_check_intvl_ms is specified, then max_health_check_intvl_ms is assumed to be
 * unbounded.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_min_health_check_intvl_ms(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS, (uint8_t *)var,
                                  sizeof(*var));
    return status;
}

/**
 * Sets @c min_health_check_intvl_ms setting for module @c wlan.
 *
 * The minimum interval to wait after the last health check before triggering another. If this
 * parameter is 0 then health checks will always happen at the max_interval_ms value.
 * min_interval_ms must always be less than or equal to max_interval_ms. If only
 * min_health_check_intvl_ms is specified, then max_health_check_intvl_ms is assumed to be
 * unbounded.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_min_health_check_intvl_ms(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS, NULL, 0);
    return status;
}

/**
 * Gets @c offload_arp_refresh_s setting for module @c wlan.
 *
 * If non zero, enables ARP refresh offload with the specified interval in seconds. Note: ARP
 * response offload needs to be enabled for this feature to work.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_offload_arp_refresh_s(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S, (uint8_t *)var,
                                  sizeof(*var));
    return status;
}

/**
 * Sets @c offload_arp_refresh_s setting for module @c wlan.
 *
 * If non zero, enables ARP refresh offload with the specified interval in seconds. Note: ARP
 * response offload needs to be enabled for this feature to work.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_offload_arp_refresh_s(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S, NULL, 0);
    return status;
}

/**
 * Gets @c offload_arp_response setting for module @c wlan.
 *
 * If true, enables ARP response offload which allows the Morse chip to directly respond to ARP
 * requests without waking up the host processor.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_offload_arp_response(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE, (uint8_t *)var,
                                  sizeof(*var));
    return status;
}

/**
 * Sets @c offload_arp_response setting for module @c wlan.
 *
 * If true, enables ARP response offload which allows the Morse chip to directly respond to ARP
 * requests without waking up the host processor.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_offload_arp_response(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE, NULL, 0);
    return status;
}

/**
 * Gets @c password setting for module @c wlan.
 *
 * Password used when associating, 1-32 characters long.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_string_32 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_password(
    struct mmagic_controller *controller, struct struct_string_32 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_PASSWORD, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_PASSWORD, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c password setting for module @c wlan.
 *
 * Password used when associating, 1-32 characters long.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c struct_string_32 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_password(
    struct mmagic_controller *controller, const char *var)
{
    struct struct_string_32 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_PASSWORD, (uint8_t *)&var_val, sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_PASSWORD, NULL, 0);
    return status;
}

/**
 * Gets @c pmf_mode setting for module @c wlan.
 *
 * Protected Management Frame mode to use (802.11w)
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_pmf_mode to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_pmf_mode(
    struct mmagic_controller *controller, enum mmagic_pmf_mode *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_PMF_MODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_PMF_MODE, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c pmf_mode setting for module @c wlan.
 *
 * Protected Management Frame mode to use (802.11w)
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_pmf_mode to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_pmf_mode(
    struct mmagic_controller *controller, enum mmagic_pmf_mode var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_PMF_MODE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_PMF_MODE, NULL, 0);
    return status;
}

/**
 * Gets @c power_save_mode setting for module @c wlan.
 *
 * Sets the 802.11 power save mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_power_save_mode to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_power_save_mode(
    struct mmagic_controller *controller, enum mmagic_power_save_mode *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_POWER_SAVE_MODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_POWER_SAVE_MODE, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c power_save_mode setting for module @c wlan.
 *
 * Sets the 802.11 power save mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_power_save_mode to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_power_save_mode(
    struct mmagic_controller *controller, enum mmagic_power_save_mode var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_POWER_SAVE_MODE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_POWER_SAVE_MODE, NULL, 0);
    return status;
}

/**
 * Gets @c raw_priority setting for module @c wlan.
 *
 * Priority to request if raw is supported by the AP. Valid priorities are 0-7. -1 disables RAW.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c int16_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_raw_priority(
    struct mmagic_controller *controller, int16_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_RAW_PRIORITY, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_RAW_PRIORITY, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c raw_priority setting for module @c wlan.
 *
 * Priority to request if raw is supported by the AP. Valid priorities are 0-7. -1 disables RAW.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c int16_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_raw_priority(
    struct mmagic_controller *controller, int16_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_RAW_PRIORITY, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_RAW_PRIORITY, NULL, 0);
    return status;
}

/**
 * Gets @c rts_threshold setting for module @c wlan.
 *
 * The RTS threshold (in octets) to set, or 0 to disable.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_rts_threshold(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_RTS_THRESHOLD, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_RTS_THRESHOLD, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c rts_threshold setting for module @c wlan.
 *
 * The RTS threshold (in octets) to set, or 0 to disable.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_rts_threshold(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_RTS_THRESHOLD, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_RTS_THRESHOLD, NULL, 0);
    return status;
}

/**
 * Gets @c security setting for module @c wlan.
 *
 * Security type to used when associating.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_security_type to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_security(
    struct mmagic_controller *controller, enum mmagic_security_type *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SECURITY, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SECURITY, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c security setting for module @c wlan.
 *
 * Security type to used when associating.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_security_type to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_security(
    struct mmagic_controller *controller, enum mmagic_security_type var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SECURITY, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SECURITY, NULL, 0);
    return status;
}

/**
 * Gets @c sgi_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether SGI support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_sgi_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SGI_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SGI_ENABLED, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c sgi_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether SGI support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_sgi_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SGI_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SGI_ENABLED, NULL, 0);
    return status;
}

/**
 * Gets @c ssid setting for module @c wlan.
 *
 * SSID of the AP to connect to, can be 1-32 characters long.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_string_32 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_ssid(
    struct mmagic_controller *controller, struct struct_string_32 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SSID, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SSID, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c ssid setting for module @c wlan.
 *
 * SSID of the AP to connect to, can be 1-32 characters long.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c struct_string_32 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_ssid(
    struct mmagic_controller *controller, const char *var)
{
    struct struct_string_32 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SSID, (uint8_t *)&var_val, sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SSID, NULL, 0);
    return status;
}

/**
 * Gets @c station_type setting for module @c wlan.
 *
 * S1G non-AP STA type.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_station_type to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_station_type(
    struct mmagic_controller *controller, enum mmagic_station_type *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STATION_TYPE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STATION_TYPE, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c station_type setting for module @c wlan.
 *
 * S1G non-AP STA type.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_station_type to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_station_type(
    struct mmagic_controller *controller, enum mmagic_station_type var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STATION_TYPE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STATION_TYPE, NULL, 0);
    return status;
}

/**
 * Gets @c subbands_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether sub-band support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_subbands_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SUBBANDS_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SUBBANDS_ENABLED, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c subbands_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether sub-band support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_subbands_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SUBBANDS_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SUBBANDS_ENABLED, NULL, 0);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_COMMIT,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_COMMIT,
                                  0, NULL, 0);
    return status;
}

/** @} */

/** Command arguments structure for wlan_connect */
struct MM_PACKED mmagic_core_wlan_connect_cmd_args
{
    /** Duration in milliseconds to wait for connection establish, if connection does not get
     * established an explicit disconnect will be sent. 0 to return immediately without waiting */
    uint32_t timeout;
};

/**
 * Brings up the WLAN interface and connects to the AP with configured parameters.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_connect(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_connect_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_CONNECT, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_CONNECT, 0,
                                  NULL, 0);
    return status;
}

/**
 * Disconnects and brings down the WLAN interface.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_disconnect(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_DISCONNECT, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_DISCONNECT, 0,
                                NULL, 0);
    return status;
}

/** Command arguments structure for wlan_scan */
struct MM_PACKED mmagic_core_wlan_scan_cmd_args
{
    /** Duration in milliseconds to wait for scan to complete, if scan does not complete by the
     * timeout any available results will be returned and the scan aborted. */
    uint32_t timeout;
};

/** Response arguments structure for wlan_scan */
struct MM_PACKED mmagic_core_wlan_scan_rsp_args
{
    /** Reference to structure to store the results of the scan. */
    struct struct_scan_status results;
};

/**
 * Starts an undirected scan for available networks.
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_scan(struct mmagic_controller *controller,
                                                             struct mmagic_core_wlan_scan_cmd_args *
                                                             cmd_args,
                                                             struct mmagic_core_wlan_scan_rsp_args *
                                                             rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SCAN, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SCAN, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** Response arguments structure for wlan_get_rssi */
struct MM_PACKED mmagic_core_wlan_get_rssi_rsp_args
{
    /** The RSSI in dBm. */
    int32_t rssi;
};

/**
 * Retrieves the RSSI if the WLAN interface is up, else 0.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_get_rssi(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_get_rssi_rsp_args *rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET_RSSI, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET_RSSI, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** Response arguments structure for wlan_get_mac_addr */
struct MM_PACKED mmagic_core_wlan_get_mac_addr_rsp_args
{
    /** Buffer to receive the MAC address. */
    struct struct_mac_addr mac_addr;
};

/**
 * Retrieves the MAC address if the WLAN interface is up.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_get_mac_addr(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_get_mac_addr_rsp_args *rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET_MAC_ADDR,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET_MAC_ADDR,
                                  0, (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** Command arguments structure for wlan_wnm_sleep */
struct MM_PACKED mmagic_core_wlan_wnm_sleep_cmd_args
{
    /** Boolean indicating whether WNM sleep is enabled. */
    bool wnm_sleep_enabled;
};

/**
 * Requests entry or exit from extended sleep (wnm sleep) if the WLAN interface is up.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_wnm_sleep(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_wnm_sleep_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_WNM_SLEEP, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_WNM_SLEEP, 0,
                                  NULL, 0);
    return status;
}

/** Command arguments structure for wlan_beacon_monitor_enable */
struct MM_PACKED mmagic_core_wlan_beacon_monitor_enable_cmd_args
{
    /** OUIs to monitor. */
    struct struct_oui_list oui_filter;
};

/**
 * Enable beacon monitoring with the given filter settings. If beacon monitoring is already enabled
 * it will be reconfigured with the given arguments.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_beacon_monitor_enable(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_beacon_monitor_enable_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_BEACON_MONITOR_ENABLE, 0, (uint8_t *)cmd_args,
                                  sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_BEACON_MONITOR_ENABLE, 0, NULL, 0);
    return status;
}

/**
 * Disable beacon monitoring. If beacon monitor is not enabled then this has no effect.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_beacon_monitor_disable(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_BEACON_MONITOR_DISABLE, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                MMAGIC_WLAN_CMD_BEACON_MONITOR_DISABLE, 0, NULL, 0);
    return status;
}

/**
 * This puts the Morse chip into standby mode allowing the host processor to go to sleep while the
 * Morse chip takes over certain functionality to keep the connection alive with the provision to
 * wake up the host processor when certain conditions are met.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_enter(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_STANDBY_ENTER,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_STANDBY_ENTER,
                                0, NULL, 0);
    return status;
}

/**
 * Forces the Morse chip to exit standby mode. There may be certain instances such as a timer
 * expiry, which cause the host chip to wake up independant of the Morse chip. In such situations,
 * the host calls this function to instruct the Morse chip to exit standby mode and return to normal
 * operating mode.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_exit(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_STANDBY_EXIT,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_STANDBY_EXIT, 0,
                                NULL, 0);
    return status;
}

/** Command arguments structure for wlan_standby_set_status_payload */
struct MM_PACKED mmagic_core_wlan_standby_set_status_payload_cmd_args
{
    /** Payload to append to standby status packets. */
    struct struct_buffer64 payload;
};

/**
 * Sets the user payload for the standby status packet. Once standby mode is enabled, the Morse chip
 * will periodically emit a UDP standby status packet regardless of whether it is in standby or not.
 * The UDP packet will also be sent immediately upon entering or exiting Standby mode. If this
 * command is not executed then the standby status packet will contain no payload.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_set_status_payload(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_standby_set_status_payload_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_STATUS_PAYLOAD, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_STATUS_PAYLOAD, 0, NULL, 0);
    return status;
}

/** Command arguments structure for wlan_standby_set_wake_filter */
struct MM_PACKED mmagic_core_wlan_standby_set_wake_filter_cmd_args
{
    /** Filter to apply to wake packets to wake on match. */
    struct struct_buffer64 filter;
    /** Offset within wake packet payload to apply the filter. */
    uint32_t offset;
};

/**
 * Configures the standby mode UDP wake packet filter. The system can be woken up from standby mode
 * by sending it a UDP wake packet. If a wake filter is set using this function then the wake packet
 * will only wake up the system if the specified filter pattern matches the payload at the specified
 * offset within the payload. If this command is not executed then any wake packet will wake up the
 * system.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_set_wake_filter(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_standby_set_wake_filter_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_WAKE_FILTER, 0, (uint8_t *)cmd_args,
                                  sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_WAKE_FILTER, 0, NULL, 0);
    return status;
}

/** Command arguments structure for wlan_standby_set_config */
struct MM_PACKED mmagic_core_wlan_standby_set_config_cmd_args
{
    /** Interval in seconds for transmitting Standby status packets. (Default 15s) */
    uint32_t notify_period_s;
    /** Source IP address to use for the standby status packets. (Default 0.0.0.0) */
    struct struct_ip_addr src_ip;
    /** Destination IP address for the standby status packets. (Default 0.0.0.0) */
    struct struct_ip_addr dst_ip;
    /** Destination UDP Port for the standby status packets, also used the source port for outgoing
     * UDP port for outgoing UDP packets. (Default 22000) */
    uint16_t dst_port;
    /** The interval in seconds to wait after beacon loss before entering snooze mode. In snooze
     * mode the Morse chip stops listening for beacons to save power. (Default 120s) */
    uint32_t bss_inactivity_s;
    /** The interval in seconds to wake periodically from snooze mode and check for beacons. If no
     * beacons are found then the Morse chip will re-enter snooze mode. If beacons are found then
     * the Morse chip will exit standby mode so the host can reassociate. (Default 60s) */
    uint32_t snooze_period_s;
    /** The amount in seconds to increase successive snooze intervals. This saves power by snoozing
     * for longer before checking for beacons again if no beacons are found. (Default 0s) */
    uint32_t snooze_increment_s;
    /** The maximum time in seconds to snooze for after increments. (Default unlimited) */
    uint32_t snooze_max_s;
};

/**
 * Sets the standby mode configuration parameters. If this command is not executed then the defaults
 * are as specified.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_set_config(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_standby_set_config_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_CONFIG, 0, (uint8_t *)cmd_args,
                                  sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_CONFIG, 0, NULL, 0);
    return status;
}

/** Event arguments structure for wlan_beacon_rx */
struct MM_PACKED mmagic_wlan_beacon_rx_event_args
{
    /** Raw octet string of Vendor Information Elements contained in the beacon. Only the IEs that
     * match the configured filters are returned. If multiple matching IEs are present then they are
     * concatenated in the buffer. Each IE is a TLV where the first byte is the Tag (0xDD for Vendor
     * Specific IE), followed by a byte specifying the length IE contents (i.e., excluding the Tag
     * and Length). */
    struct struct_packet_buffer vendor_ies;
};

/**
 * Handler for the wlan-beacon_rx event.
 *
 * Triggered when a beacon matching the configured beacon monitor filter(s) is received.
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param args Notication arguments received from the agent.
 * @param arg  Opaque argument that was provided when the callbcak was registered.
 */
typedef void (*mmagic_wlan_beacon_rx_event_handler_t)(
    const struct mmagic_wlan_beacon_rx_event_args *args, void *arg);

/**
 * Register a handler for the wlan-beacon_rx event.
 *
 * Triggered when a beacon matching the configured beacon monitor filter(s) is received.
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller Reference to the the controller handle.
 * @param handler    The handler function to register.
 * @param arg        Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_wlan_beacon_rx_handler(
    struct mmagic_controller *controller,
    mmagic_wlan_beacon_rx_event_handler_t handler, void *arg);

/** Event arguments structure for wlan_standby_exit */
struct MM_PACKED mmagic_wlan_standby_exit_event_args
{
    /** Reason why we exited standby mode. If we manually exited standby mode through a call to
     * wlan-standby_exit, then the reason will be standby_exit_none. */
    enum mmagic_standby_mode_exit_reason reason;
};

/**
 * Handler for the wlan-standby_exit event.
 *
 * Triggered when chip exits standby mode either manually or through an event.
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param args Notication arguments received from the agent.
 * @param arg  Opaque argument that was provided when the callbcak was registered.
 */
typedef void (*mmagic_wlan_standby_exit_event_handler_t)(
    const struct mmagic_wlan_standby_exit_event_args *args, void *arg);

/**
 * Register a handler for the wlan-standby_exit event.
 *
 * Triggered when chip exits standby mode either manually or through an event.
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller Reference to the the controller handle.
 * @param handler    The handler function to register.
 * @param arg        Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_wlan_standby_exit_handler(
    struct mmagic_controller *controller,
    mmagic_wlan_standby_exit_event_handler_t handler, void *arg);

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_IP IP Stack Management subsystem (ip)
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_IP_CONFIG ip configuration variables
 * @{
 */

/**
 * Gets @c dhcp_enabled setting for module @c ip.
 *
 * True to enable DHCP for IP address configuration, or false to use the static configuration given
 * by ip_addr, netmask, and gateway. This will take effect when the reload command is successfully
 * executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_dhcp_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DHCP_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DHCP_ENABLED, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c dhcp_enabled setting for module @c ip.
 *
 * True to enable DHCP for IP address configuration, or false to use the static configuration given
 * by ip_addr, netmask, and gateway. This will take effect when the reload command is successfully
 * executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_dhcp_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DHCP_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DHCP_ENABLED, NULL, 0);
    return status;
}

/**
 * Gets @c dhcp_offload setting for module @c ip.
 *
 * If true, enables DHCP offload which allows the Morse chip to directly handle DHCP discovery and
 * leases without waking up the host processor. Note: this comes into effect only if ip.dhcp_enabled
 * is also true.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_dhcp_offload(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DHCP_OFFLOAD, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DHCP_OFFLOAD, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c dhcp_offload setting for module @c ip.
 *
 * If true, enables DHCP offload which allows the Morse chip to directly handle DHCP discovery and
 * leases without waking up the host processor. Note: this comes into effect only if ip.dhcp_enabled
 * is also true.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_dhcp_offload(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DHCP_OFFLOAD, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DHCP_OFFLOAD, NULL, 0);
    return status;
}

/**
 * Gets @c dns_server0 setting for module @c ip.
 *
 * Primary DNS server IP address. If a value is specified this will override the primary DNS server
 * provided by DHCP (if any). Changes will take effect when the reload command is successfully
 * executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_dns_server0(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DNS_SERVER0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DNS_SERVER0, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c dns_server0 setting for module @c ip.
 *
 * Primary DNS server IP address. If a value is specified this will override the primary DNS server
 * provided by DHCP (if any). Changes will take effect when the reload command is successfully
 * executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_dns_server0(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DNS_SERVER0, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DNS_SERVER0, NULL, 0);
    return status;
}

/**
 * Gets @c dns_server1 setting for module @c ip.
 *
 * Secondary DNS server IP address. If a value is specified this will override the secondary DNS
 * server provided by DHCP (if any). Changes  will take effect when the reload command is
 * successfully executed. Note that this option may be ignored by some IP stacks.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_dns_server1(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DNS_SERVER1, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DNS_SERVER1, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c dns_server1 setting for module @c ip.
 *
 * Secondary DNS server IP address. If a value is specified this will override the secondary DNS
 * server provided by DHCP (if any). Changes  will take effect when the reload command is
 * successfully executed. Note that this option may be ignored by some IP stacks.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_dns_server1(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DNS_SERVER1, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DNS_SERVER1, NULL, 0);
    return status;
}

/**
 * Gets @c gateway setting for module @c ip.
 *
 * Gateway to use for a static network connection. This will take effect when the reload command is
 * successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_gateway(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_GATEWAY, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_GATEWAY, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c gateway setting for module @c ip.
 *
 * Gateway to use for a static network connection. This will take effect when the reload command is
 * successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_gateway(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_GATEWAY, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_GATEWAY, NULL, 0);
    return status;
}

/**
 * Gets @c ip_addr setting for module @c ip.
 *
 * IP address to use for a static network connection. This will take effect when the reload command
 * is successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_ip_addr(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_IP_ADDR, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_IP_ADDR, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c ip_addr setting for module @c ip.
 *
 * IP address to use for a static network connection. This will take effect when the reload command
 * is successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_ip_addr(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_IP_ADDR, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_IP_ADDR, NULL, 0);
    return status;
}

/**
 * Gets @c netmask setting for module @c ip.
 *
 * Netmask to use for a static network connection. This will take effect when the reload command is
 * successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_netmask(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_NETMASK, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_NETMASK, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c netmask setting for module @c ip.
 *
 * Netmask to use for a static network connection. This will take effect when the reload command is
 * successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_netmask(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_NETMASK, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_NETMASK, NULL, 0);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_ip_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_COMMIT, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_COMMIT, 0,
                                  NULL, 0);
    return status;
}

/** @} */

/** Response arguments structure for ip_status */
struct MM_PACKED mmagic_core_ip_status_rsp_args
{
    /** Reference to the struct to return the IP status retrieved from the network stack. */
    struct struct_ip_status status;
};

/**
 * Gets the status of the IP stack.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_status(struct mmagic_controller *controller,
                                                             struct mmagic_core_ip_status_rsp_args *
                                                             rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP, MMAGIC_IP_CMD_STATUS, 0, NULL,
                                  0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_IP, MMAGIC_IP_CMD_STATUS, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/**
 * Reloads the IP stack network configuration based on the current values in the subsystem config.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_reload(struct mmagic_controller *controller)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP, MMAGIC_IP_CMD_RELOAD, 0, NULL,
                                  0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_IP, MMAGIC_IP_CMD_RELOAD, 0, NULL, 0);
    return status;
}

/** Command arguments structure for ip_enable_tcp_keepalive_offload */
struct MM_PACKED mmagic_core_ip_enable_tcp_keepalive_offload_cmd_args
{
    /** Interval in seconds to send the keep-alive packets in. */
    uint16_t period_s;
    /** The number of times to retry before giving up. */
    uint8_t retry_count;
    /** The interval in seconds to wait between retries. */
    uint8_t retry_interval_s;
};

/**
 * Enables sending periodic TCP keep-alive packets by the morse chip allowing the TCP connection to
 * be maintained without waking up the host processor. This needs to be enabled before opening a TCP
 * connection. As of now, this feature will work only on the first TCP connection opened after this
 * command.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_enable_tcp_keepalive_offload(
    struct mmagic_controller *controller,
    struct
    mmagic_core_ip_enable_tcp_keepalive_offload_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_ENABLE_TCP_KEEPALIVE_OFFLOAD, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_ENABLE_TCP_KEEPALIVE_OFFLOAD, 0, NULL, 0);
    return status;
}

/**
 * Disables sending of TCP keepalive packets.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_disable_tcp_keepalive_offload(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_DISABLE_TCP_KEEPALIVE_OFFLOAD, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_IP,
                                MMAGIC_IP_CMD_DISABLE_TCP_KEEPALIVE_OFFLOAD, 0, NULL, 0);
    return status;
}

/** Command arguments structure for ip_set_whitelist_filter */
struct MM_PACKED mmagic_core_ip_set_whitelist_filter_cmd_args
{
    /** The IPv4 source address to match, 0.0.0.0 for any. */
    struct struct_ip_addr src_ip;
    /** The IPv4 destination address to match, 0.0.0.0 for any. (Usually our IP address) */
    struct struct_ip_addr dest_ip;
    /** The netmask to apply to the source or destination IP, 0.0.0.0 for any. */
    struct struct_ip_addr netmask;
    /** The source port to match, 0 for any. */
    uint16_t src_port;
    /** The destination port to match, 0 for any. */
    uint16_t dest_port;
    /** The IPv4 protocol number to match - 6 for TCP, 17 for UDP, 0 for any. */
    uint8_t ip_protocol;
    /** The LLC protocol (or EtherType) to match - 0x0800 for IPv4 and 0x86DD for IPv6, 0 for any.
     */
    uint16_t llc_protocol;
};

/**
 * Sets the whitelist filter specifing which incoming packets can wake the system from standby mode.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_set_whitelist_filter(
    struct mmagic_controller *controller,
    struct
    mmagic_core_ip_set_whitelist_filter_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_SET_WHITELIST_FILTER, 0, (uint8_t *)cmd_args,
                                  sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_SET_WHITELIST_FILTER, 0, NULL, 0);
    return status;
}

/**
 * Clears any applied whitelist filters.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_clear_whitelist_filter(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_CLEAR_WHITELIST_FILTER, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_IP,
                                MMAGIC_IP_CMD_CLEAR_WHITELIST_FILTER, 0, NULL, 0);
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_PING Ping application subsystem (ping)
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_PING_CONFIG ping configuration variables
 * @{
 */

/**
 * Gets @c count setting for module @c ping.
 *
 * This specifies the number of ping requests to send before terminating the session. If this is
 * zero or exceeds UINT16_MAX (65535) then it it will be set to UINT16_MAX.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ping_count(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_COUNT, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_COUNT, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c count setting for module @c ping.
 *
 * This specifies the number of ping requests to send before terminating the session. If this is
 * zero or exceeds UINT16_MAX (65535) then it it will be set to UINT16_MAX.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ping_count(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_COUNT, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_COUNT, NULL, 0);
    return status;
}

/**
 * Gets @c interval setting for module @c ping.
 *
 * The time interval between ping requests (in milliseconds).
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ping_interval(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_INTERVAL, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_INTERVAL, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c interval setting for module @c ping.
 *
 * The time interval between ping requests (in milliseconds).
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ping_interval(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_INTERVAL, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_INTERVAL, NULL, 0);
    return status;
}

/**
 * Gets @c target setting for module @c ping.
 *
 * The IP address of the ping target.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ping_target(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_TARGET, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_TARGET, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c target setting for module @c ping.
 *
 * The IP address of the ping target.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ping_target(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_TARGET, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_TARGET, NULL, 0);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_ping_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_COMMIT,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_COMMIT,
                                  0, NULL, 0);
    return status;
}

/** @} */

/** Response arguments structure for ping_run */
struct MM_PACKED mmagic_core_ping_run_rsp_args
{
    /** Reference to the struct to return the status of the ping session. */
    struct struct_ping_status status;
};

/**
 * Commences a ping session using the current values in the the subsystem config.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ping_run(struct mmagic_controller *controller,
                                                            struct mmagic_core_ping_run_rsp_args *
                                                            rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_PING, MMAGIC_PING_CMD_RUN, 0, NULL,
                                  0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_PING, MMAGIC_PING_CMD_RUN, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_IPERF Iperf application subsystem (iperf)
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_IPERF_CONFIG iperf configuration variables
 * @{
 */

/**
 * Gets @c amount setting for module @c iperf.
 *
 * This specifies the duration for client transfers specified either in seconds or bytes. If this is
 * negative, it specifies a time in seconds; if positive, it specifies the number of bytes to
 * transmit.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c int32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_iperf_amount(
    struct mmagic_controller *controller, int32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_AMOUNT, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_AMOUNT, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c amount setting for module @c iperf.
 *
 * This specifies the duration for client transfers specified either in seconds or bytes. If this is
 * negative, it specifies a time in seconds; if positive, it specifies the number of bytes to
 * transmit.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c int32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_iperf_amount(
    struct mmagic_controller *controller, int32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_AMOUNT, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_AMOUNT, NULL, 0);
    return status;
}

/**
 * Gets @c mode setting for module @c iperf.
 *
 * The iperf mode to use. Valid values are udp_server, tcp_server, udp_client and tcp_client. If not
 * set, defaults to udp_server.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_iperf_mode to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_iperf_mode(
    struct mmagic_controller *controller, enum mmagic_iperf_mode *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_MODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_MODE, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c mode setting for module @c iperf.
 *
 * The iperf mode to use. Valid values are udp_server, tcp_server, udp_client and tcp_client. If not
 * set, defaults to udp_server.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_iperf_mode to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_iperf_mode(
    struct mmagic_controller *controller, enum mmagic_iperf_mode var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_MODE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_MODE, NULL, 0);
    return status;
}

/**
 * Gets @c port setting for module @c iperf.
 *
 * Specifies the local port to listen on when in server mode or the server port to send data to when
 * in client mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint16_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_iperf_port(
    struct mmagic_controller *controller, uint16_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_PORT, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_PORT, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c port setting for module @c iperf.
 *
 * Specifies the local port to listen on when in server mode or the server port to send data to when
 * in client mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint16_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_iperf_port(
    struct mmagic_controller *controller, uint16_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_PORT, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_PORT, NULL, 0);
    return status;
}

/**
 * Gets @c server setting for module @c iperf.
 *
 * IP address of server to connect to when in client mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_iperf_server(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_SERVER, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_SERVER, (uint8_t *)var, sizeof(*var));
    return status;
}

/**
 * Sets @c server setting for module @c iperf.
 *
 * IP address of server to connect to when in client mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_iperf_server(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_SERVER, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_SERVER, NULL, 0);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_iperf_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_COMMIT,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_COMMIT,
                                  0, NULL, 0);
    return status;
}

/** @} */

/** Response arguments structure for iperf_run */
struct MM_PACKED mmagic_core_iperf_run_rsp_args
{
    /** Reference to the struct to return the status of the iperf session. */
    struct struct_iperf_status status;
};

/**
 * Starts an iperf session using the current values in the the subsystem config.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_iperf_run(struct mmagic_controller *controller,
                                                             struct mmagic_core_iperf_run_rsp_args *
                                                             rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IPERF, MMAGIC_IPERF_CMD_RUN, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_IPERF, MMAGIC_IPERF_CMD_RUN, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_SYS System management subsystem (sys)
 * @{
 */

/**
 * Performs a soft reset.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_sys_reset(struct mmagic_controller *controller)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_SYS,
                                  MMAGIC_SYS_CMD_RESET, 0, NULL, 0);
    return status;
}

/** Command arguments structure for sys_deep_sleep */
struct MM_PACKED mmagic_core_sys_deep_sleep_cmd_args
{
    /** Deep sleep mode to enter. */
    enum mmagic_deep_sleep_mode mode;
};

/**
 * Enters deep sleep mode.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_sys_deep_sleep(
    struct mmagic_controller *controller,
    struct
    mmagic_core_sys_deep_sleep_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_SYS, MMAGIC_SYS_CMD_DEEP_SLEEP, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_SYS, MMAGIC_SYS_CMD_DEEP_SLEEP, 0,
                                  NULL, 0);
    return status;
}

/** Response arguments structure for sys_get_version */
struct MM_PACKED mmagic_core_sys_get_version_rsp_args
{
    /** Reference to structure to store the version information. */
    struct struct_version_info results;
};

/**
 * Gets the device firmware and hardware versions.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_sys_get_version(
    struct mmagic_controller *controller,
    struct
    mmagic_core_sys_get_version_rsp_args *rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_SYS, MMAGIC_SYS_CMD_GET_VERSION, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_SYS, MMAGIC_SYS_CMD_GET_VERSION, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_TCP TCP Socket IO subsystem (tcp)
 * @{
 */

/** Command arguments structure for tcp_connect */
struct MM_PACKED mmagic_core_tcp_connect_cmd_args
{
    /** URL of the server to connect to. */
    struct struct_string_254 url;
    /** TCP port to connect to. */
    uint16_t port;
};

/** Response arguments structure for tcp_connect */
struct MM_PACKED mmagic_core_tcp_connect_rsp_args
{
    /** Stream ID of the opened socket. */
    uint8_t stream_id;
};

/**
 * Opens a client TCP socket and returns its stream ID
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_connect(struct mmagic_controller *controller,
                                                               struct
                                                               mmagic_core_tcp_connect_cmd_args *
                                                               cmd_args,
                                                               struct
                                                               mmagic_core_tcp_connect_rsp_args *
                                                               rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_CONNECT, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_CONNECT, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** Command arguments structure for tcp_bind */
struct MM_PACKED mmagic_core_tcp_bind_cmd_args
{
    /** TCP port to listen on. */
    uint16_t port;
};

/** Response arguments structure for tcp_bind */
struct MM_PACKED mmagic_core_tcp_bind_rsp_args
{
    /** Stream ID of the opened socket. */
    uint8_t stream_id;
};

/**
 * Opens a server TCP socket and returns its stream ID
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_bind(struct mmagic_controller *controller,
                                                            struct mmagic_core_tcp_bind_cmd_args *
                                                            cmd_args,
                                                            struct mmagic_core_tcp_bind_rsp_args *
                                                            rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_BIND, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_BIND, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** Command arguments structure for tcp_recv */
struct MM_PACKED mmagic_core_tcp_recv_cmd_args
{
    /** Stream ID of the socket to receive from. */
    uint8_t stream_id;
    /** TCP port to listen on. */
    uint16_t len;
    /** Timeout in ms. 0 to return immediately, UINT32_MAX to wait indefinately. */
    uint32_t timeout;
};

/** Response arguments structure for tcp_recv */
struct MM_PACKED mmagic_core_tcp_recv_rsp_args
{
    /** Buffer of read data. */
    struct struct_packet_buffer buffer;
};

/**
 * Reads from a socket
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_recv(struct mmagic_controller *controller,
                                                            struct mmagic_core_tcp_recv_cmd_args *
                                                            cmd_args,
                                                            struct mmagic_core_tcp_recv_rsp_args *
                                                            rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    stream_id = cmd_args->stream_id;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_RECV, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_RECV, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** Command arguments structure for tcp_send */
struct MM_PACKED mmagic_core_tcp_send_cmd_args
{
    /** Stream ID of the socket to send on. */
    uint8_t stream_id;
    /** Buffer to send. */
    struct struct_packet_buffer buffer;
};

/**
 * Writes to a socket
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_send(struct mmagic_controller *controller,
                                                            struct mmagic_core_tcp_send_cmd_args *
                                                            cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    stream_id = cmd_args->stream_id;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_SEND, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_SEND, 0, NULL,
                                  0);
    return status;
}

/** Command arguments structure for tcp_read_poll */
struct MM_PACKED mmagic_core_tcp_read_poll_cmd_args
{
    /** Stream ID of the socket to wait on. */
    uint8_t stream_id;
    /** Timeout in ms. 0 to return immediately, UINT32_MAX to wait indefinately. */
    uint32_t timeout;
};

/**
 * Polls the socket till it is ready for reading
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_read_poll(
    struct mmagic_controller *controller,
    struct
    mmagic_core_tcp_read_poll_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    stream_id = cmd_args->stream_id;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_READ_POLL, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_READ_POLL, 0,
                                  NULL, 0);
    return status;
}

/** Command arguments structure for tcp_write_poll */
struct MM_PACKED mmagic_core_tcp_write_poll_cmd_args
{
    /** Stream ID of the socket to wait on. */
    uint8_t stream_id;
    /** Timeout in ms. 0 to return immediately, UINT32_MAX to wait indefinately. */
    uint32_t timeout;
};

/**
 * Polls the socket till it is ready for writing
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_write_poll(
    struct mmagic_controller *controller,
    struct
    mmagic_core_tcp_write_poll_cmd_args *cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    stream_id = cmd_args->stream_id;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_WRITE_POLL, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_WRITE_POLL, 0,
                                  NULL, 0);
    return status;
}

/** Command arguments structure for tcp_accept */
struct MM_PACKED mmagic_core_tcp_accept_cmd_args
{
    /** Stream ID of the bound socket. */
    uint8_t stream_id;
};

/** Response arguments structure for tcp_accept */
struct MM_PACKED mmagic_core_tcp_accept_rsp_args
{
    /** Stream ID of the new incoming connection. */
    uint8_t stream_id;
};

/**
 * Waits for an incoming socket connection and returns a new stream ID.
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_accept(struct mmagic_controller *controller,
                                                              struct mmagic_core_tcp_accept_cmd_args
                                                              *cmd_args,
                                                              struct mmagic_core_tcp_accept_rsp_args
                                                              *rsp_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    stream_id = cmd_args->stream_id;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_ACCEPT, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_ACCEPT, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args));
    return status;
}

/** Command arguments structure for tcp_close */
struct MM_PACKED mmagic_core_tcp_close_cmd_args
{
    /** Stream ID of the socket to close. */
    uint8_t stream_id;
};

/**
 * Closes and frees the socket
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_close(struct mmagic_controller *controller,
                                                             struct mmagic_core_tcp_close_cmd_args *
                                                             cmd_args)
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_CLOSE, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_CLOSE, 0, NULL,
                                  0);
    return status;
}

/** @} */

#ifdef __cplusplus
}
#endif

/** @} */
