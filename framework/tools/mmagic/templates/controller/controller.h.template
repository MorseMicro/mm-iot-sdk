{#- --------------------- Macros --------------------- -#}
{% import 'mmagic_common.j2' as mm %}
{#- --------------------- Begin actual template --------------------- -#}
/*
 * Copyright {{config.copyright_year}} Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#pragma once

/**
 * @ingroup MMAGIC
 * @defgroup MMAGIC_CONTROLLER Morse M2M Interface Controller API
 *
 * @{
 *
 * This module provides a small implementation of the Controller stack for integration with
 * application software. This code mostly stands alone from the rest of the Morse IoT SDK.
 *
 * To integrate the Controller code into your application:
 * * Copy the files in this directory into your application.
 * * Also copy `mmutils/mmutils.h`, `mmutils/mmbuf.h`, and `mmutils/mmbuf.c` into your application.
 * * Implement the APIs defined by `mmagic_datalink_controller.h` and `mmosal_controller.h`. (See
 *   the @c m2m_controller.c application as a reference.)
 * * Include mmagic_controller.h in your application to integrate the Controller functionality.
 */

#include <stddef.h>


#ifdef __cplusplus
extern "C" {
#endif

#ifndef MM_PACKED
/** Macro for packed structs */
#define MM_PACKED __attribute__((packed))
#endif

/**
 * @defgroup MMAGIC_CONTROLLER_DATA_TYPES Data types
 *
 * @{
 */

{% for enum in config.enums %}
/** {{enum.description}} */
{{enum.datatype}}
{
    {%- for value in enum.values %}
    /** {{value.description}} */
    MMAGIC_{{enum.name | regex_replace('enum_(?P<name>.*)', '\\g<name>') | upper}}_{{value.name.upper()}} = {{value.value}},
    {%- endfor %}
};
{% endfor %}

{% for struct in config.structs %}
/** {{struct.description}} */
{{struct.decl_datatype}}
{
    {%- for element in struct.elements %}
    /** {{element.description}} */
    {{config.find_datatype(element.type)}} {{element.name}}{{config.get_array_element(element.type)}};
    {%- endfor %}
};
{% endfor -%}

/**
 * Subsytem IDs
 */
enum mmagic_subsystem
{
    {%- for module in config.modules %}
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_{{module.name.upper()}} */
    {{mm.module_label(config, module)}} = {{module.id}},
    {%- endfor %}
};

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_INIT Initialization/deinitialization
 * @{
 */

/**
 * Controller struct used internally by the data-link. This will be specific to each
 * type of controller. i.e SPI and UART may have different elements in the struct.
 */
struct mmagic_controller;

/**
 * Prototype for callback function invoked whenever any time a event that the agent has
 * started is received.
 *
 * @note This callback will execute in the context of the Controller data link receive thread.
 *
 * @param controller Reference to the the controller handle.
 * @param arg User argument that was given when the callback was registered.
 */
typedef void (*mmagic_controller_agent_start_cb_t)(struct mmagic_controller *controller, void *arg);

/**
 * Initialization structure for mmagic_controller.
 */
struct mmagic_controller_init_args
{
    /** Callback function to executed any time a event that the agent has started is received.*/
    mmagic_controller_agent_start_cb_t agent_start_cb;
    /** User argument that will be passed when the agent_start_cb is executed. */
    void *agent_start_arg;
};

/**
 * Initializer for @ref mmagic_controller_init_args.
 */
#define MMAGIC_CONTROLLER_ARGS_INIT { 0 }

/**
 * Initialize the Controller.
 *
 * @param  args Reference to the initialization arguments for the mmagic_controller.
 *              May be @c NULL, in which case default values will be used.
 *
 * @return      Reference to the created controller handle on success. @c Null on error.
 */
struct mmagic_controller *mmagic_controller_init(const struct mmagic_controller_init_args *args);

/**
 * Deinitialize the Controller. Any resources used will be freed.
 *
 * @param controller Reference to the controller handle.
 */
void mmagic_controller_deinit(struct mmagic_controller *controller);


/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_INTERNAL Data types, etc., for internal use
 * @{
 *
 * Enumerations, etc., used by the underlying implementation, but which are not usually
 * needed to be used directly.
 */

/** The stream ID of the control stream */
#define CONTROL_STREAM  0

/**
 * Sends a command to the agent.
 *
 * @param controller    A user context to be passed.
 * @param stream_id     The stream id to send this command on.
 * @param submodule_id  The submodule to target with this command.
 * @param command_id    The command.
 * @param subcommand_id A sub command or resource id if applicable.
 * @param buffer        A pointer to any data associated with this command.
                        May be NULL if none.
 * @param buffer_length Length of above data.
 *
 * @return              MMAGIC_STATUS_OK on success, else an error code.
 */
enum mmagic_status mmagic_controller_tx(
    struct mmagic_controller *controller, uint8_t stream_id,
    uint8_t submodule_id, uint8_t command_id, uint8_t subcommand_id,
    const uint8_t* buffer, size_t buffer_length);

/**
 * Waits for a response from the agent.
 *
 * @param controller    Controller context.
 * @param stream_id     The stream id to wait on.
 * @param submodule_id  The submodule to wait on.
 * @param command_id    The command to wait on.
 * @param subcommand_id A sub command or resource id if applicable.
 * @param buffer        A pointer to a buffer to load with any returned data.
                        May be NULL if none.
 * @param buffer_length Length of above buffer.
 *
 * @return              MMAGIC_STATUS_OK on success, else an error code.
 */
enum mmagic_status mmagic_controller_rx(struct mmagic_controller* controller, uint8_t stream_id, uint8_t submodule_id,
                         uint8_t command_id, uint8_t subcommand_id,
                         uint8_t* buffer, size_t buffer_length);


{% for module in config.modules %}
{% if module.configs -%}
/** {{module.name}} configuration variable IDs */
enum mmagic_{{module.name}}_var
{
    {%- for var in module.configs %}
    /** {{var.description}} */
    {{mm.var_label(config, module, var)}} = {{loop.index0}},
    {%- endfor %}
};
{%- endif %}

/** {{module.name}} configuration command IDs */
enum mmagic_{{module.name}}_cmd
{
    /** Retrieve the value of a configuration variable */
    {{mm.cmd_label(config, module, "get")}} = 0,
    /** Set the value of a configuration variable */
    {{mm.cmd_label(config, module, "set")}} = 1,
    /** Reserved (unused) */
    {{mm.cmd_label(config, module, "load")}} = 2,
    /** Commit the current configuration to flash */
    {{mm.cmd_label(config, module, "commit")}} = 3,
    {%- for command in module.commands %}
    /** {{command.description }} */
    {{mm.cmd_label(config, module, command.name)}} = {{command.id}},
    {%- endfor %}
};
{% endfor %}

/** @} */


{% for module in config.modules %}
/**
 * @defgroup MMAGIC_CONTROLLER_{{module.name.upper()}} {{module.description}} subsystem ({{module.name}})
 * @{
 */

{% if module.configs -%}
/**
 * @defgroup MMAGIC_CONTROLLER_{{module.name.upper()}}_CONFIG {{module.name}} configuration variables
 * @{
 */

{% for var in module.configs %}
/**
 * Gets @c {{var.name}} setting for module @c {{module.name}}.
 *
 * {{var.description}}
 *
 * @param controller    Reference to the controller handle.
 * @param var           Reference to the @c {{var.type}} to place the received data in.
 *
 * @return              MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_{{module.name}}_{{var.name}}(struct mmagic_controller *controller, {{config.find_datatype(var.type)}} *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "get")}}, {{mm.var_label(config, module, var)}}, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "get")}}, {{mm.var_label(config, module, var)}}, (uint8_t*) var, sizeof(*var));
    return status;
}

{% if config.datatype_is_scalar(var.type) -%}
/**
 * Sets @c {{var.name}} setting for module @c {{module.name}}.
 *
 * {{var.description}}
 *
 * @param controller    Reference to the controller handle.
 * @param var           The @c {{var.type}} to write.
 *
 * @return              MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_{{module.name}}_{{var.name}}(struct mmagic_controller *controller, {{config.find_datatype(var.type)}} var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "set")}}, {{mm.var_label(config, module, var)}}, (uint8_t*)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "set")}}, {{mm.var_label(config, module, var)}}, NULL, 0);
    return status;
}
{% elif var.type.startswith("struct_string") %}
/**
 * Sets @c {{var.name}} setting for module @c {{module.name}}.
 *
 * {{var.description}}
 *
 * @param controller    Reference to the controller handle.
 * @param var           The @c {{var.type}} to write.
 *
 * @return              MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_{{module.name}}_{{var.name}}(struct mmagic_controller *controller, const char *var)
{
    {{config.find_datatype(var.type)}} var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "set")}}, {{mm.var_label(config, module, var)}}, (uint8_t*)&var_val, sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "set")}}, {{mm.var_label(config, module, var)}}, NULL, 0);
    return status;
}
{% else -%}
/**
 * Sets @c {{var.name}} setting for module @c {{module.name}}.
 *
 * {{var.description}}
 *
 * @param controller    Reference to the controller handle.
 * @param var           Reference to the @c {{var.type}} to write.
 *
 * @return              MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_{{module.name}}_{{var.name}}(struct mmagic_controller *controller, {{config.find_datatype(var.type)}} *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "set")}}, {{mm.var_label(config, module, var)}}, (uint8_t*) var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "set")}}, {{mm.var_label(config, module, var)}}, NULL, 0);
    return status;
}
{% endif -%}
{% endfor %}

/**
 * Saves all settings from persistent store.
 *
 * @param controller    Reference to the controller handle.
 *
 * @return              MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_{{module.name}}_commit_all(struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "commit")}}, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, "commit")}}, 0, NULL, 0);
    return status;
}

/** @} */

{% endif %}

{%- for command in module.commands %}
{%- if command.command_args %}
/** Command arguments structure for {{module.name}}_{{command.name}} */
struct MM_PACKED mmagic_core_{{module.name}}_{{command.name}}_cmd_args
{
    {%- for arg in command.command_args %}
    /** {{ arg.description }} */
    {{config.find_datatype(arg.type)}} {{arg.name}}{{config.get_array_element(arg.type)}};
    {%- endfor %}
};
{% endif %}
{%- if command.response_args %}
/** Response arguments structure for {{module.name}}_{{command.name}} */
struct MM_PACKED mmagic_core_{{module.name}}_{{command.name}}_rsp_args
{
    {%- for arg in command.response_args %}
    /** {{ arg.description }} */
    {{config.find_datatype(arg.type)}} {{arg.name}}{{config.get_array_element(arg.type)}};
    {%- endfor %}
};
{% endif %}
{%- if command.command_args %}
{%- if command.response_args %}
/**
 * {{command.description}}
 *
 * @param controller        Reference to the controller handle.
 * @param[in] cmd_args      Command arguments
 * @param[out] rsp_args     Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_{{module.name}}_{{command.name}}(struct mmagic_controller *controller,
    struct mmagic_core_{{module.name}}_{{command.name}}_cmd_args *cmd_args,
    struct mmagic_core_{{module.name}}_{{command.name}}_rsp_args *rsp_args)
{%- else %}
/**
 * {{command.description}}
 *
 * @param controller        Reference to the controller handle.
 * @param[in] cmd_args      Command arguments
 *
 * @return @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_{{module.name}}_{{command.name}}(struct mmagic_controller *controller,
    struct mmagic_core_{{module.name}}_{{command.name}}_cmd_args *cmd_args)
{%- endif %}
{%- else %}
{%- if command.response_args %}
/**
 * {{command.description}}
 *
 * @param controller        Reference to the controller handle.
 * @param[out] rsp_args     Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_{{module.name}}_{{command.name}}(struct mmagic_controller *controller,
    struct mmagic_core_{{module.name}}_{{command.name}}_rsp_args *rsp_args)
{%- else %}
/**
 * {{command.description}}
 *
 * @param controller         Reference to the controller handle.
 *
 * @return @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_{{module.name}}_{{command.name}}(struct mmagic_controller *controller)
{%- endif %}
{%- endif %}
{
    enum mmagic_status status;
    uint8_t stream_id = CONTROL_STREAM;
{%- if command.stream_type %}
    stream_id = cmd_args->stream_id;
{%- endif %}
{#- Special handling for sys-reset since it does not return a response #}
{%- if module.name == "sys" and command.name == "reset" %}
    status = mmagic_controller_tx(controller, stream_id, {{mm.module_label(config, module)}},
        {{mm.cmd_label(config, module, command.name)}}, 0, NULL, 0);
{%- elif command.command_args %}
{%- if command.response_args %}
    status = mmagic_controller_tx(controller, stream_id, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, command.name)}}, 0, (uint8_t*) cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, command.name)}}, 0, (uint8_t*) rsp_args, sizeof(*rsp_args));
{%- else %}
    status = mmagic_controller_tx(controller, stream_id, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, command.name)}}, 0, (uint8_t*) cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, command.name)}}, 0, NULL, 0);
{%- endif %}
{%- else %}
{%- if command.response_args %}
    status = mmagic_controller_tx(controller, stream_id, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, command.name)}}, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, command.name)}}, 0, (uint8_t*) rsp_args, sizeof(*rsp_args));
{%- else %}
    status = mmagic_controller_tx(controller, stream_id, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, command.name)}}, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, {{mm.module_label(config, module)}}, {{mm.cmd_label(config, module, command.name)}}, 0, NULL, 0);
{%- endif %}
{%- endif %}
    return status;
}
{% endfor %}

{% for event in module.events %}
{%- if event.event_args -%}
/** Event arguments structure for {{module.name}}_{{event.name}} */
struct MM_PACKED mmagic_{{module.name}}_{{event.name}}_event_args
{
    {%- for arg in event.event_args %}
    /** {{arg.description}} */
    {{config.find_datatype(arg.type)}} {{arg.name}}{{config.get_array_element(arg.type)}};
    {%- endfor %}
};

/**
 * Handler for the {{module.name}}-{{event.name}} event.
 *
 * {{event.description}}
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param args  Notication arguments received from the agent.
 * @param arg   Opaque argument that was provided when the callbcak was registered.
 */
typedef void (*mmagic_{{module.name}}_{{event.name}}_event_handler_t)(const struct mmagic_{{module.name}}_{{event.name}}_event_args *args, void *arg);
{%-else %}
/**
 * Handler for the {{module.name}}-{{event.name}} event.
 *
 * {{event.description}}
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param arg   Opaque argument that was provided when the callbcak was registered.
 */
typedef void (*mmagic_{{module.name}}_{{event.name}}_event_handler_t)(void *arg);
{%- endif %}

/**
 * Register a handler for the {{module.name}}-{{event.name}} event.
 *
 * {{event.description}}
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller    Reference to the the controller handle.
 * @param handler       The handler function to register.
 * @param arg           Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_{{module.name}}_{{event.name}}_handler(
    struct mmagic_controller *controller,
    mmagic_{{module.name}}_{{event.name}}_event_handler_t handler, void *arg);
{% endfor %}


/** @} */
{% endfor %}


#ifdef __cplusplus
}
#endif

/** @} */
