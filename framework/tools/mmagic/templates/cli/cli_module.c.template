/*
 * Copyright {{config.copyright_year}} Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 *
 * Note: The corresponding headers files must be included BEFORE this def file. Additionally this
 *       file should only be in one (and only one) compilation unit (.c/.cpp file).
 */
#include <ctype.h>

#include "mmconfig.h"
#include "mmutils.h"
#include "cli/mmagic_cli.h"
#include "cli/autogen/mmagic_cli_internal.h"


/*
 * The fixed width that the key will be padded to, with trailing spaces, before the value is
 * printed.
 */
#define KEY_NAME_PADDING 32

/********* Getters **********/
{% for var in data.configs | sort(attribute="id") %}
{%- if config.datatype_is_raw(var.type) %}
int mmagic_cli_{{data.name}}_get_{{var.name}}(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_{{data.name}}_data *data = mmagic_data_get_{{data.name}}(core);
    const char *key_name = "{{data.name}}.{{var.name}}";
    MM_STATIC_ASSERT((sizeof("{{data.name}}.{{var.name}}") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    if (data->config.{{var.name}}.len == 0)
    {
        mmagic_cli_printf(cli, "%-*s (empty)", KEY_NAME_PADDING, key_name);
        return 0;
    }

    /* Check if the value is printable */
    bool is_printable = true;
    for (size_t ii = 0; ii < data->config.{{var.name}}.len; ii++)
    {
        if (!isprint(data->config.{{var.name}}.data[ii]))
        {
            is_printable = false;
            break;
        }
    }
    if (is_printable)
    {
        mmagic_cli_printf(cli, "%-*s%.*s", KEY_NAME_PADDING, key_name, data->config.{{var.name}}.len, data->config.{{var.name}}.data);
    }
    else
    {
        mmagic_cli_printf(cli, "%-*s(hex dump)", KEY_NAME_PADDING, key_name);
        /* We only print up to 16 hex values per line. With prefix (by design) this will not
         * exceed 80 chars. */
        char buf[80];
        for (size_t ii = 0; ii < data->config.{{var.name}}.len; ii += 16)
        {
            int offset = snprintf(buf, sizeof(buf), "    0x%04x:", ii);
            if (offset < 0)
            {
                return -1;
            }
            for (size_t jj = 0; jj < 16 && ii + jj < data->config.{{var.name}}.len; jj++)
            {
                int ret = snprintf(buf + offset, sizeof(buf) - offset, " %02x",
                                   data->config.{{var.name}}.data[jj]);
                if (ret < 0)
                {
                    return -1;
                }
                offset += ret;
            }
            embeddedCliPrint(cli, buf);
        }
    }
    return 0;
}
{%- else %}
int mmagic_cli_{{data.name}}_get_{{var.name}}(struct mmagic_data *core, EmbeddedCli *cli)
{
    struct mmagic_{{data.name}}_data *data = mmagic_data_get_{{data.name}}(core);
    const char *key_name = "{{data.name}}.{{var.name}}";
    MM_STATIC_ASSERT((sizeof("{{data.name}}.{{var.name}}") - 1) < KEY_NAME_PADDING,
                     "Key must be shorter than padding");

    char buf[MMAGIC_CLI_PRINT_BUF_LEN] = {0};
    /* -1 to allow for a NULL terminator at the end */
    const size_t max_str_len = sizeof(buf) - 1;
    size_t cursor = 0;
    int written = 0;

    written = snprintf(&buf[cursor], max_str_len - cursor, "%-*s", KEY_NAME_PADDING, key_name);
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    {%- set ref = config.datatype_ref_prefix(var.type) %}
    written = mmagic_{{var.type}}_to_string({{ref}}data->config.{{var.name}},
                &buf[cursor], max_str_len - cursor);
    if (written == 0)
    {
        /*
         * The value we just tried writing ended up being empty. Move the cursor back to the end of
         * the key and denote that it has an empty value.
         */
        const uint32_t key_len = strlen(key_name);
        cursor = key_len;
        written = snprintf(&buf[cursor], max_str_len - cursor, " (empty)");
    }
    if (written < 0 || (cursor + written) > max_str_len)
    {
        return -1;
    }
    cursor += written;

    embeddedCliPrint(cli, buf);

    return 0;
}
{%- endif %}
{% endfor %}

/********* Setters **********/
{% for var in data.configs | sort(attribute="id") %}
{%- if config.datatype_is_raw(var.type) %}
int mmagic_cli_{{data.name}}_set_{{var.name}}(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_{{data.name}}_data *data = mmagic_data_get_{{data.name}}(core);

    /* Since this argument has been parsed by the CLI parser, which uses null characters for
     * delimiters, there are limitations to the characters that can be encoded. For example,
     * it is not possible to set values that include null characters via the CLI. */
    size_t len = strlen(val);
    if (len > sizeof(data->config.{{var.name}}.data))
    {
        return -1;
    }

    memcpy(data->config.{{var.name}}.data, val, len);
    data->config.{{var.name}}.len = len;

    mmagic_cli_{{data.name}}_get_{{var.name}}(core, cli);
    return 0;
}
{%- else %}
int mmagic_cli_{{data.name}}_set_{{var.name}}(struct mmagic_data *core, EmbeddedCli *cli, const char *val)
{
    struct mmagic_{{data.name}}_data *data = mmagic_data_get_{{data.name}}(core);

    if (mmagic_string_to_{{var.type}}(&data->config.{{var.name}}, val))
    {
        return -1;
    }

    mmagic_cli_{{data.name}}_get_{{var.name}}(core, cli);

    return 0;
}
{%- endif %}
{% endfor %}

/********* Dictionary **********
 *
 * This list must be in alphabetical order as @c mmagic_cli_element_search() is implemented using
 * a binary search which requires an ordered list.
 */
struct mmagic_cli_config_elem {{data.name}}_cli_config_vars[] = {
{%- for var in data.configs | sort(attribute="name") %}
    {"{{var.name}}", mmagic_cli_{{data.name}}_get_{{var.name}}, mmagic_cli_{{data.name}}_set_{{var.name}}},
{%- endfor %}
};

/********* {{data.name|upper}} Configuration Getter/Setter Handlers **********/
void mmagic_cli_{{data.name}}_get(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var)
{
    struct mmagic_data *core = &ctx->core;

    if (config_var == NULL)
    {
        embeddedCliPrint(cli, "Invalid argument");
        return;
    }

    uint32_t num_elements = sizeof({{data.name}}_cli_config_vars)/sizeof({{data.name}}_cli_config_vars[0]);

    if (!strcmp("all", config_var))
    {
        for (; num_elements > 0; num_elements--)
        {
            {{data.name}}_cli_config_vars[num_elements-1].get(core, cli);
        }
        return;
    }

    struct mmagic_cli_config_elem *elem = mmagic_cli_element_search({{data.name}}_cli_config_vars, num_elements, config_var);
    if (elem == NULL)
    {
        mmagic_cli_printf(cli, "Unable to find config variable '{{data.name}}.%s'", config_var);
        return;
    }

    if (elem->get == NULL)
    {
        embeddedCliPrint(cli, "Unable to find getter");
        return;
    }

    if (elem->get(core, cli))
    {
        embeddedCliPrint(cli, "Get function failed");
    }
}

void mmagic_cli_{{data.name}}_set(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var, const char *val)
{
    struct mmagic_data *core = &ctx->core;

    uint32_t num_elements = sizeof({{data.name}}_cli_config_vars)/sizeof({{data.name}}_cli_config_vars[0]);

    struct mmagic_cli_config_elem *elem = mmagic_cli_element_search({{data.name}}_cli_config_vars, num_elements, config_var);
    if (elem == NULL)
    {
        mmagic_cli_printf(cli, "Unable to find config variable '{{data.name}}.%s'", config_var);
        return;
    }

    if (elem->set == NULL)
    {
        embeddedCliPrint(cli, "Unable to find setter");
        return;
    }

    if (elem->set(core, cli, val))
    {
        mmagic_cli_printf(cli, "Set {{data.name}}.%s failed", elem->name);
    }
}

/********* Persistence *******/
void mmagic_cli_{{data.name}}_commit(struct mmagic_cli *ctx, EmbeddedCli *cli, const char *config_var)
{
    if ((config_var != NULL) && strcmp("all", config_var))
    {
        embeddedCliPrint(cli, "Unexpected argument! Only \'{{data.name}}\' or \'{{data.name}}.all\' supported.");
        return;
    }

    {% if data.configs -%}
    mmagic_core_{{data.name}}_save_all(&ctx->core);
    embeddedCliPrint(cli, "Successfully committed '{{data.name}}' variables");
    {% else %}
    MM_UNUSED(ctx);
    {%- endif %}
}

void mmagic_cli_{{data.name}}_load(struct mmagic_cli *ctx, EmbeddedCli *cli)
{
    MM_UNUSED(cli);
    {% if data.configs -%}
    mmagic_core_{{data.name}}_load_all(&ctx->core);
    {% else %}
    MM_UNUSED(ctx);
    {%- endif %}
}

/********* CLI Command Handlers **********/
{% for command in data.commands %}
void mmagic_cli_{{data.name}}_{{command.name}}(EmbeddedCli *cli, char *args, void *context);
{%- endfor %}

/********* Register bindings function definition **********/
void mmagic_cli_{{data.name}}_register_bindings(EmbeddedCli *cli, struct mmagic_data *core)
{
    {% for command in data.commands %}
    embeddedCliAddBinding(cli, (CliCommandBinding) {
        "{{data.name}}-{{command.name}}",
        "{{command.description}}",
        true,
        core,
        mmagic_cli_{{data.name}}_{{command.name}}
    });
    {% endfor %}
}

void mmagic_cli_{{data.name}}_init(struct mmagic_cli *ctx)
{
    /* Register Commands */
    mmagic_cli_{{data.name}}_register_bindings(ctx->cli, &ctx->core);

    /* Register config variable accessor functions */
    struct mmagic_cli_config_accessor *accessor =
        (struct mmagic_cli_config_accessor *)mmosal_malloc(sizeof(*accessor));
    MMOSAL_ASSERT(accessor);

    mmosal_safer_strcpy(accessor->name, "{{data.name}}", sizeof(accessor->name));
    accessor->get = mmagic_cli_{{data.name}}_get;
    accessor->set = mmagic_cli_{{data.name}}_set;
    accessor->commit = mmagic_cli_{{data.name}}_commit;
    accessor->next = NULL;

    mmagic_cli_register_config_accessor(ctx, accessor);
}
