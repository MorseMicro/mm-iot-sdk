/*
 * Copyright {{config.copyright_year}} Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#include "mmagic_core_types.h"
#include "mmosal.h"

/* --------------------  types -------------------- */

{% for enum in config.enums %}
static const struct {{enum.name}}_string_lut
{
    const char *string_value;
    {{enum.datatype}} enum_value;
} {{enum.name}}_string_lut[] = {
{%- for value in enum.values %}
    {
        .string_value = "{{value.name}}",
        .enum_value = {{enum.value_identifier(value)}},
    },
{%- endfor %}
};

int mmagic_{{enum.name}}_to_string({{enum.datatype}} value, char *buf, size_t len)
{
    size_t ii;
    for (ii = 0; ii < (sizeof({{enum.name}}_string_lut)/sizeof({{enum.name}}_string_lut[0])); ii++)
    {
        if ({{enum.name}}_string_lut[ii].enum_value == value)
        {
            return snprintf(buf, len, "%s", {{enum.name}}_string_lut[ii].string_value);
        }
    }
    return -1;
}

int mmagic_string_to_{{enum.name}}({{enum.datatype}} *value, const char *buf)
{
    size_t ii;
    for (ii = 0; ii < (sizeof({{enum.name}}_string_lut)/sizeof({{enum.name}}_string_lut[0])); ii++)
    {
        if (strcasecmp(buf, {{enum.name}}_string_lut[ii].string_value) == 0)
        {
            *value =  {{enum.name}}_string_lut[ii].enum_value;
            return 0;
        }
    }
    return -1;
}
{% endfor %}

/* -------------------- Basic types -------------------- */

int mmagic_bool_to_string(bool value, char *buf, size_t len)
{
    return snprintf(buf, len, "%s", value ? "true" : "false");
}

int mmagic_string_to_bool(bool *value, const char *buf)
{
    if (strcasecmp("true", buf) == 0)
    {
        *value = true;
        return 0;
    }
    else if (strcasecmp("false", buf) == 0)
    {
        *value = false;
        return 0;
    }

    return -1;
}

int mmagic_uint16_t_to_string(uint16_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%u", value);
}

int mmagic_string_to_uint16_t(uint16_t *value, const char *buf)
{
    int32_t parsed_val = strtoul(buf, NULL, 10);
    if (parsed_val < 0 || parsed_val > UINT16_MAX)
    {
        return -1;
    }
    *value = (uint16_t)parsed_val;
    return 0;
}

int mmagic_int16_t_to_string(int16_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%d", value);
}

int mmagic_string_to_int16_t(int16_t *value, const char *buf)
{
    int parsed_val = strtol(buf, NULL, 10);
    if (parsed_val < 0 || parsed_val > INT16_MAX || parsed_val < INT16_MIN)
    {
        return -1;
    }
    *value = (int16_t)parsed_val;
    return 0;
}

int mmagic_uint32_t_to_string(uint32_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%lu", value);
}

int mmagic_string_to_uint32_t(uint32_t *value, const char *buf)
{
    int parsed_val = strtoul(buf, NULL, 10);
    if (parsed_val < 0)
    {
        return parsed_val;
    }
    *value = (uint32_t)parsed_val;
    return 0;
}

int mmagic_int32_t_to_string(int32_t value, char *buf, size_t len)
{
    return snprintf(buf, len, "%ld", value);
}

int mmagic_string_to_int32_t(int32_t *value, const char *buf)
{
    int32_t parsed_val = strtol(buf, NULL, 10);
    *value = (int32_t)parsed_val;
    return 0;
}


/* -------------------- Struct types -------------------- */

int mmagic_struct_country_code_to_string(const struct struct_country_code *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", 2, value->country_code);
}

int mmagic_string_to_struct_country_code(struct struct_country_code *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->country_code));
    if (len > sizeof(value->country_code) - 1)
    {
        return -1;
    }

    strncpy((char *)value->country_code, buf, len);

    return 0;
}

int mmagic_struct_ip_addr_to_string(const struct struct_ip_addr *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", strnlen(value->addr, sizeof(value->addr)), value->addr);
}

int mmagic_string_to_struct_ip_addr(struct struct_ip_addr *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->addr));
    if (len > sizeof(value->addr) - 1)
    {
        return -1;
    }

    strncpy((char *)value->addr, buf, len);
    /* Set the last character to terminate the string */
    value->addr[len] = 0;

    return 0;
}

int mmagic_struct_mac_addr_to_string(const struct struct_mac_addr *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%02x:%02x:%02x:%02x:%02x:%02x",
                    value->addr[0], value->addr[1], value->addr[2],
                    value->addr[3], value->addr[4], value->addr[5]);
}

int mmagic_string_to_struct_mac_addr(struct struct_mac_addr *value, const char *buf)
{
    /* Need to provide an array of ints to sscanf otherwise it will overflow */
    int temp[6];
    int i;

    int ret = sscanf(buf, "%x:%x:%x:%x:%x:%x",
                     &temp[0], &temp[1], &temp[2],
                     &temp[3], &temp[4], &temp[5]);
    if (ret != 6)
    {
        return -1;
    }

    for (i = 0; i < 6; i++)
    {
        if (temp[i] > UINT8_MAX || temp[i] < 0)
        {
            return -1;
        }

        value->addr[i] = (uint8_t)temp[i];
    }

    return 0;
}

int mmagic_struct_string_32_to_string(const struct struct_string_32 *value, char *buf, size_t len)
{
    return snprintf(buf, len, "%.*s", (int)value->len, value->data);
}

int mmagic_string_to_struct_string_32(struct struct_string_32 *value, const char *buf)
{
    size_t len = strnlen(buf, sizeof(value->data));
    if (len > sizeof(value->data) - 1)
    {
        return -1;
    }

    strncpy((char *)value->data, buf, len);
    value->len = len;

    return 0;
}
