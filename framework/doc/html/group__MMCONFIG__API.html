<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Morse Micro IoT SDK: Morse Micro Persistent Configuration Store API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.svg" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Morse Micro IoT SDK
   &#160;<span id="projectnumber">2.9.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__MMCONFIG__API.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Morse Micro Persistent Configuration Store API<div class="ingroups"><a class="el" href="group__MMCONFIG.html">Morse Micro Persistent Configuration Store</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >This API provides functionality for managing configuration data in a key/value store with a flash backend. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmmconfig__update__node.html">mmconfig_update_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update node structure.  <a href="structmmconfig__update__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab3cffa2dca70681dbe466bfef906c681"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#gab3cffa2dca70681dbe466bfef906c681">MMCONFIG_MAX_KEYLEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:gab3cffa2dca70681dbe466bfef906c681"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of a key in bytes.  <a href="group__MMCONFIG__API.html#gab3cffa2dca70681dbe466bfef906c681">More...</a><br /></td></tr>
<tr class="separator:gab3cffa2dca70681dbe466bfef906c681"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3f0ca3ae6640a9e5436d2b7c89d36f17"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga3f0ca3ae6640a9e5436d2b7c89d36f17">mmconfig_result</a> { <br />
&#160;&#160;<a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17ae5f4ef8549c5981e901d41f2244022fc">MMCONFIG_OK</a> = 0
, <a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17a6cd75bd7c511513b2727538bbdd93c45">MMCONFIG_DATA_ERASED</a> = 1
, <a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17a8ce7634e6681dc0483ba51b80dc8a9b8">MMCONFIG_ERR_INVALID_KEY</a> = -1
, <a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17a0a9fec9bfccadd007dec11f11fab60f8">MMCONFIG_ERR_FULL</a> = -2
, <br />
&#160;&#160;<a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17a02b121df80bbc267f64fc3a1be0e3a9f">MMCONFIG_ERR_NOT_FOUND</a> = -3
, <a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17aff2d6680c21aa604154c2cd02a511414">MMCONFIG_ERR_INCORRECT_TYPE</a> = -4
, <a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17ae0ccd7c7a9288e659885ace1d3c11e6f">MMCONFIG_ERR_INVALID_PARTITION</a> = -5
, <a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17ad9fa6f3e01fba709e8918853be100cb6">MMCONFIG_ERR_INSUFFICIENT_MEMORY</a> = -6
, <br />
&#160;&#160;<a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17a99381b75c3ebdb311a231de78213292e">MMCONFIG_ERR_OUT_OF_BOUNDS</a> = -7
, <a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17a001e24f95fa5b2a7647e02e3870b2329">MMCONFIG_ERR_NOT_SUPPORTED</a> = -8
, <a class="el" href="group__MMCONFIG__API.html#gga3f0ca3ae6640a9e5436d2b7c89d36f17ae51358eb11318a13715b767f9fcd2bf5">MMCONFIG_ERR_WILDCARD_KEY</a> = -9
<br />
 }</td></tr>
<tr class="memdesc:ga3f0ca3ae6640a9e5436d2b7c89d36f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return &amp; error codes.  <a href="group__MMCONFIG__API.html#ga3f0ca3ae6640a9e5436d2b7c89d36f17">More...</a><br /></td></tr>
<tr class="separator:ga3f0ca3ae6640a9e5436d2b7c89d36f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga74809c11ae255459a980efda8327f650"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga74809c11ae255459a980efda8327f650">mmconfig_eraseall</a> (void)</td></tr>
<tr class="memdesc:ga74809c11ae255459a980efda8327f650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all flash blocks allocated to persistent storage and write the signature at the 2 copies in flash.  <a href="group__MMCONFIG__API.html#ga74809c11ae255459a980efda8327f650">More...</a><br /></td></tr>
<tr class="separator:ga74809c11ae255459a980efda8327f650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1379a02dfbef05b86b02a475f09f484"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#gab1379a02dfbef05b86b02a475f09f484">mmconfig_write_data</a> (const char *key, const void *data, size_t size)</td></tr>
<tr class="memdesc:gab1379a02dfbef05b86b02a475f09f484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the raw data to persistent store location identified by key.  <a href="group__MMCONFIG__API.html#gab1379a02dfbef05b86b02a475f09f484">More...</a><br /></td></tr>
<tr class="separator:gab1379a02dfbef05b86b02a475f09f484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga116bd92e4bd372a3964ff66dce82a657"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga116bd92e4bd372a3964ff66dce82a657">mmconfig_delete_key</a> (const char *key)</td></tr>
<tr class="memdesc:ga116bd92e4bd372a3964ff66dce82a657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the specified key(s) from persistent store.  <a href="group__MMCONFIG__API.html#ga116bd92e4bd372a3964ff66dce82a657">More...</a><br /></td></tr>
<tr class="separator:ga116bd92e4bd372a3964ff66dce82a657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d00758a37662b66f89386065f3e13f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga72d00758a37662b66f89386065f3e13f">mmconfig_write_update_node_list</a> (const struct <a class="el" href="structmmconfig__update__node.html">mmconfig_update_node</a> *node_list)</td></tr>
<tr class="memdesc:ga72d00758a37662b66f89386065f3e13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all updates from the update node list to persistent store.  <a href="group__MMCONFIG__API.html#ga72d00758a37662b66f89386065f3e13f">More...</a><br /></td></tr>
<tr class="separator:ga72d00758a37662b66f89386065f3e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75d2af944e63a2b6f5615ba8a4e7ad6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#gad75d2af944e63a2b6f5615ba8a4e7ad6">mmconfig_write_string</a> (const char *key, const char *value)</td></tr>
<tr class="memdesc:gad75d2af944e63a2b6f5615ba8a4e7ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the null terminated string to persistent store location identified by key.  <a href="group__MMCONFIG__API.html#gad75d2af944e63a2b6f5615ba8a4e7ad6">More...</a><br /></td></tr>
<tr class="separator:gad75d2af944e63a2b6f5615ba8a4e7ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a03e759500ae9d9395a22d3846c11e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga49a03e759500ae9d9395a22d3846c11e">mmconfig_read_string</a> (const char *key, char *buffer, int bufsize)</td></tr>
<tr class="memdesc:ga49a03e759500ae9d9395a22d3846c11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the persistent store string value identified by the key.  <a href="group__MMCONFIG__API.html#ga49a03e759500ae9d9395a22d3846c11e">More...</a><br /></td></tr>
<tr class="separator:ga49a03e759500ae9d9395a22d3846c11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5b0b985172bf514b863064b84f5228"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#gaed5b0b985172bf514b863064b84f5228">mmconfig_alloc_and_load</a> (const char *key, void **data)</td></tr>
<tr class="memdesc:gaed5b0b985172bf514b863064b84f5228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory and loads the data from persistent memory into it returning a pointer.  <a href="group__MMCONFIG__API.html#gaed5b0b985172bf514b863064b84f5228">More...</a><br /></td></tr>
<tr class="separator:gaed5b0b985172bf514b863064b84f5228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093ef5caa1ee5d2d49ac26510e3f8d3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga093ef5caa1ee5d2d49ac26510e3f8d3b">mmconfig_write_int</a> (const char *key, int value)</td></tr>
<tr class="memdesc:ga093ef5caa1ee5d2d49ac26510e3f8d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given integer to a string and writes to persistent store.  <a href="group__MMCONFIG__API.html#ga093ef5caa1ee5d2d49ac26510e3f8d3b">More...</a><br /></td></tr>
<tr class="separator:ga093ef5caa1ee5d2d49ac26510e3f8d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525c691a659dbd32281c0de12432d9c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga525c691a659dbd32281c0de12432d9c9">mmconfig_read_int</a> (const char *key, int *value)</td></tr>
<tr class="memdesc:ga525c691a659dbd32281c0de12432d9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer stored in persistent store identified by the key.  <a href="group__MMCONFIG__API.html#ga525c691a659dbd32281c0de12432d9c9">More...</a><br /></td></tr>
<tr class="separator:ga525c691a659dbd32281c0de12432d9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8339629d27f454f568df2f68e457d5bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga8339629d27f454f568df2f68e457d5bd">mmconfig_write_uint32</a> (const char *key, uint32_t value)</td></tr>
<tr class="memdesc:ga8339629d27f454f568df2f68e457d5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given unsigned integer to a string and writes to persistent store.  <a href="group__MMCONFIG__API.html#ga8339629d27f454f568df2f68e457d5bd">More...</a><br /></td></tr>
<tr class="separator:ga8339629d27f454f568df2f68e457d5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93df8026b038c5b216f7dc16a65ce91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#gae93df8026b038c5b216f7dc16a65ce91">mmconfig_read_uint32</a> (const char *key, uint32_t *value)</td></tr>
<tr class="memdesc:gae93df8026b038c5b216f7dc16a65ce91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unsigned integer stored in persistent store identified by the key.  <a href="group__MMCONFIG__API.html#gae93df8026b038c5b216f7dc16a65ce91">More...</a><br /></td></tr>
<tr class="separator:gae93df8026b038c5b216f7dc16a65ce91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635c965295967a5965b6bc46c763e173"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga635c965295967a5965b6bc46c763e173">mmconfig_write_bool</a> (const char *key, bool value)</td></tr>
<tr class="memdesc:ga635c965295967a5965b6bc46c763e173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given boolean to a string and writes to persistent store.  <a href="group__MMCONFIG__API.html#ga635c965295967a5965b6bc46c763e173">More...</a><br /></td></tr>
<tr class="separator:ga635c965295967a5965b6bc46c763e173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf5f8b78e861e232a9133656daf2df6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga5cf5f8b78e861e232a9133656daf2df6">mmconfig_read_bool</a> (const char *key, bool *value)</td></tr>
<tr class="memdesc:ga5cf5f8b78e861e232a9133656daf2df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boolean value stored in persistent store identified by the key.  <a href="group__MMCONFIG__API.html#ga5cf5f8b78e861e232a9133656daf2df6">More...</a><br /></td></tr>
<tr class="separator:ga5cf5f8b78e861e232a9133656daf2df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced6e1453d3114b98696af9bbcca4288"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#gaced6e1453d3114b98696af9bbcca4288">mmconfig_read_bytes</a> (const char *key, void *buffer, uint32_t buffsize, uint32_t offset)</td></tr>
<tr class="memdesc:gaced6e1453d3114b98696af9bbcca4288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the persistent store data identified by the key.  <a href="group__MMCONFIG__API.html#gaced6e1453d3114b98696af9bbcca4288">More...</a><br /></td></tr>
<tr class="separator:gaced6e1453d3114b98696af9bbcca4288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d12564d7dc99fcdec5aac2cf571669"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#gac4d12564d7dc99fcdec5aac2cf571669">mmconfig_validate_key</a> (const char *key)</td></tr>
<tr class="memdesc:gac4d12564d7dc99fcdec5aac2cf571669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates an entire key intended for data storage.  <a href="group__MMCONFIG__API.html#gac4d12564d7dc99fcdec5aac2cf571669">More...</a><br /></td></tr>
<tr class="separator:gac4d12564d7dc99fcdec5aac2cf571669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66c8ee2ad518ce126006eef13f53eb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#gaf66c8ee2ad518ce126006eef13f53eb5">mmconfig_validate_key_character</a> (char character)</td></tr>
<tr class="memdesc:gaf66c8ee2ad518ce126006eef13f53eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates a single character intended to make up a key for data storage.  <a href="group__MMCONFIG__API.html#gaf66c8ee2ad518ce126006eef13f53eb5">More...</a><br /></td></tr>
<tr class="separator:gaf66c8ee2ad518ce126006eef13f53eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da661777231d2aaaa2c8b327c707471"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga8da661777231d2aaaa2c8b327c707471">mmconfig_check_usage</a> (const struct <a class="el" href="structmmconfig__update__node.html">mmconfig_update_node</a> *node_list, uint32_t *bytes_used, int32_t *bytes_remaining)</td></tr>
<tr class="memdesc:ga8da661777231d2aaaa2c8b327c707471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of bytes that would be needed to write the given updates (if not NULL) and the number of bytes that would remain free in the persistent store afterwards.  <a href="group__MMCONFIG__API.html#ga8da661777231d2aaaa2c8b327c707471">More...</a><br /></td></tr>
<tr class="separator:ga8da661777231d2aaaa2c8b327c707471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908514f26d5872bf4b86b8f3dc012411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MMCONFIG__API.html#ga908514f26d5872bf4b86b8f3dc012411">load_mmwlan_settings</a> (void)</td></tr>
<tr class="memdesc:ga908514f26d5872bf4b86b8f3dc012411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and applies any other <code>mmwlan</code> settings specified in config store.  <a href="group__MMCONFIG__API.html#ga908514f26d5872bf4b86b8f3dc012411">More...</a><br /></td></tr>
<tr class="separator:ga908514f26d5872bf4b86b8f3dc012411"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gab3cffa2dca70681dbe466bfef906c681" name="gab3cffa2dca70681dbe466bfef906c681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3cffa2dca70681dbe466bfef906c681">&#9670;&nbsp;</a></span>MMCONFIG_MAX_KEYLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MMCONFIG_MAX_KEYLEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum length of a key in bytes. </p>

<p class="definition">Definition at line <a class="el" href="mmconfig_8h_source.html#l00216">216</a> of file <a class="el" href="mmconfig_8h_source.html">mmconfig.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3f0ca3ae6640a9e5436d2b7c89d36f17" name="ga3f0ca3ae6640a9e5436d2b7c89d36f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f0ca3ae6640a9e5436d2b7c89d36f17">&#9670;&nbsp;</a></span>mmconfig_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MMCONFIG__API.html#ga3f0ca3ae6640a9e5436d2b7c89d36f17">mmconfig_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return &amp; error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17ae5f4ef8549c5981e901d41f2244022fc" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17ae5f4ef8549c5981e901d41f2244022fc"></a>MMCONFIG_OK&#160;</td><td class="fielddoc"><p >Operation completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17a6cd75bd7c511513b2727538bbdd93c45" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17a6cd75bd7c511513b2727538bbdd93c45"></a>MMCONFIG_DATA_ERASED&#160;</td><td class="fielddoc"><p >Partition was erased. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17a8ce7634e6681dc0483ba51b80dc8a9b8" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17a8ce7634e6681dc0483ba51b80dc8a9b8"></a>MMCONFIG_ERR_INVALID_KEY&#160;</td><td class="fielddoc"><p >Key provided was invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17a0a9fec9bfccadd007dec11f11fab60f8" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17a0a9fec9bfccadd007dec11f11fab60f8"></a>MMCONFIG_ERR_FULL&#160;</td><td class="fielddoc"><p >Config store is full. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17a02b121df80bbc267f64fc3a1be0e3a9f" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17a02b121df80bbc267f64fc3a1be0e3a9f"></a>MMCONFIG_ERR_NOT_FOUND&#160;</td><td class="fielddoc"><p >Requested key was not found. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17aff2d6680c21aa604154c2cd02a511414" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17aff2d6680c21aa604154c2cd02a511414"></a>MMCONFIG_ERR_INCORRECT_TYPE&#160;</td><td class="fielddoc"><p >Requested data type did not match found data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17ae0ccd7c7a9288e659885ace1d3c11e6f" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17ae0ccd7c7a9288e659885ace1d3c11e6f"></a>MMCONFIG_ERR_INVALID_PARTITION&#160;</td><td class="fielddoc"><p >Valid partition was not found. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17ad9fa6f3e01fba709e8918853be100cb6" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17ad9fa6f3e01fba709e8918853be100cb6"></a>MMCONFIG_ERR_INSUFFICIENT_MEMORY&#160;</td><td class="fielddoc"><p >Insufficient memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17a99381b75c3ebdb311a231de78213292e" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17a99381b75c3ebdb311a231de78213292e"></a>MMCONFIG_ERR_OUT_OF_BOUNDS&#160;</td><td class="fielddoc"><p >Offset was out of bounds. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17a001e24f95fa5b2a7647e02e3870b2329" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17a001e24f95fa5b2a7647e02e3870b2329"></a>MMCONFIG_ERR_NOT_SUPPORTED&#160;</td><td class="fielddoc"><p >Operation not supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f0ca3ae6640a9e5436d2b7c89d36f17ae51358eb11318a13715b767f9fcd2bf5" name="gga3f0ca3ae6640a9e5436d2b7c89d36f17ae51358eb11318a13715b767f9fcd2bf5"></a>MMCONFIG_ERR_WILDCARD_KEY&#160;</td><td class="fielddoc"><p >Key contains wildcard valid only for deletion. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mmconfig_8h_source.html#l00219">219</a> of file <a class="el" href="mmconfig_8h_source.html">mmconfig.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga908514f26d5872bf4b86b8f3dc012411" name="ga908514f26d5872bf4b86b8f3dc012411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga908514f26d5872bf4b86b8f3dc012411">&#9670;&nbsp;</a></span>load_mmwlan_settings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void load_mmwlan_settings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and applies any other <code>mmwlan</code> settings specified in config store. </p>
<p >Specifically looks for <code>wlan.subbands_enabled</code>, <code>wlan.sgi_enabled</code>, <code>wlan.ampdu_enabled</code>, <code>wlan.fragment_threshold</code> and <code>wlan.rts_threshold</code>. </p>

</div>
</div>
<a id="gaed5b0b985172bf514b863064b84f5228" name="gaed5b0b985172bf514b863064b84f5228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5b0b985172bf514b863064b84f5228">&#9670;&nbsp;</a></span>mmconfig_alloc_and_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_alloc_and_load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory and loads the data from persistent memory into it returning a pointer. </p>
<p >It is the responsibility of the caller to free the memory when it is no longer required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">data</td><td>Returns a pointer to allocated memory loaded with the key value. Returns NULL on any error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes read and allocated on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_NOT_FOUND</code> if the specified key was not found <code>MMCONFIG_ERR_INSUFFICIENT_MEMORY</code> if memory could not be allocated Other negative number for other errors. </dd></dl>

</div>
</div>
<a id="ga8da661777231d2aaaa2c8b327c707471" name="ga8da661777231d2aaaa2c8b327c707471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da661777231d2aaaa2c8b327c707471">&#9670;&nbsp;</a></span>mmconfig_check_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_check_usage </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmmconfig__update__node.html">mmconfig_update_node</a> *&#160;</td>
          <td class="paramname"><em>node_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytes_used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>bytes_remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the number of bytes that would be needed to write the given updates (if not NULL) and the number of bytes that would remain free in the persistent store afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_list</td><td>Pointer to a linked list of nodes to be sized. May be NULL if there is nothing to store </td></tr>
    <tr><td class="paramname">bytes_used</td><td>Pointer for the size of current data plus node_list </td></tr>
    <tr><td class="paramname">bytes_remaining</td><td>Pointer for the number of bytes that would remain free if node_list was stored. May be negative if insufficient storage is available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_NOT_SUPPORTED</code> if there is no persistent store </dd></dl>

</div>
</div>
<a id="ga116bd92e4bd372a3964ff66dce82a657" name="ga116bd92e4bd372a3964ff66dce82a657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga116bd92e4bd372a3964ff66dce82a657">&#9670;&nbsp;</a></span>mmconfig_delete_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int mmconfig_delete_key </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the specified key(s) from persistent store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. For deletion a wildcard (*) may be specified at the end to delete multiple keys in one go. Must be a null terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_FULL</code> if insufficient space to write data Other negative number for other errors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mmconfig_8h_source.html#l00299">299</a> of file <a class="el" href="mmconfig_8h_source.html">mmconfig.h</a>.</p>

</div>
</div>
<a id="ga74809c11ae255459a980efda8327f650" name="ga74809c11ae255459a980efda8327f650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74809c11ae255459a980efda8327f650">&#9670;&nbsp;</a></span>mmconfig_eraseall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_eraseall </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all flash blocks allocated to persistent storage and write the signature at the 2 copies in flash. </p>
<dl class="section return"><dt>Returns</dt><dd>It returns 0 on success or an error code on failure. </dd></dl>

</div>
</div>
<a id="ga5cf5f8b78e861e232a9133656daf2df6" name="ga5cf5f8b78e861e232a9133656daf2df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cf5f8b78e861e232a9133656daf2df6">&#9670;&nbsp;</a></span>mmconfig_read_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_read_bool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the boolean value stored in persistent store identified by the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>Returns the boolean value stored, it is converted from string but may even be a single byte raw boolean value. The string representation may be "true"/"false" or a "0"/non zero integer string. On error, the value is untouched, so can be preloaded with a default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_NOT_FOUND</code> if the specified key was not found <code>MMCONFIG_ERR_INCORRECT_TYPE</code> if the data pointed to by the key is not an integer represented as a string </dd></dl>

</div>
</div>
<a id="gaced6e1453d3114b98696af9bbcca4288" name="gaced6e1453d3114b98696af9bbcca4288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced6e1453d3114b98696af9bbcca4288">&#9670;&nbsp;</a></span>mmconfig_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_read_bytes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the persistent store data identified by the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a pre-allocated buffer to return the data address in. </td></tr>
    <tr><td class="paramname">buffsize</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>An offset into the source from which to copy the data into the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns length of data copied on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_NOT_FOUND</code> if the specified key was not found <code>MMCONFIG_ERR_OUT_OF_BOUNDS</code> if the offset is out of bounds Other negative number for other errors. </dd></dl>

</div>
</div>
<a id="ga525c691a659dbd32281c0de12432d9c9" name="ga525c691a659dbd32281c0de12432d9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga525c691a659dbd32281c0de12432d9c9">&#9670;&nbsp;</a></span>mmconfig_read_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_read_int </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer stored in persistent store identified by the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>Returns the integer in this, it is converted from string. On error, the value is untouched, so can be preloaded with a default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_NOT_FOUND</code> if the specified key was not found <code>MMCONFIG_ERR_INCORRECT_TYPE</code> if the data pointed to by the key is not an integer represented as a string </dd></dl>

</div>
</div>
<a id="ga49a03e759500ae9d9395a22d3846c11e" name="ga49a03e759500ae9d9395a22d3846c11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a03e759500ae9d9395a22d3846c11e">&#9670;&nbsp;</a></span>mmconfig_read_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_read_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the persistent store string value identified by the key. </p>
<dl class="section note"><dt>Note</dt><dd>If you use <code><a class="el" href="group__MMCONFIG__API.html#ga49a03e759500ae9d9395a22d3846c11e" title="Returns the persistent store string value identified by the key.">mmconfig_read_string()</a></code> to read data written by <code><a class="el" href="group__MMCONFIG__API.html#gab1379a02dfbef05b86b02a475f09f484" title="Writes the raw data to persistent store location identified by key.">mmconfig_write_data()</a></code> then it could fail if the data is not null terminated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer to read the string into. On error, the buffer is untouched, so can be preloaded with a default value. </td></tr>
    <tr><td class="paramname">bufsize</td><td>Length of buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns length of string read on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_NOT_FOUND</code> if the specified key was not found <code>MMCONFIG_ERR_INCORRECT_TYPE</code> if the data pointed to by the key is not a null terminated string <code>MMCONFIG_ERR_INSUFFICIENT_MEMORY</code> if the buffer size is insufficient Other negative number for other errors. </dd></dl>

</div>
</div>
<a id="gae93df8026b038c5b216f7dc16a65ce91" name="gae93df8026b038c5b216f7dc16a65ce91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae93df8026b038c5b216f7dc16a65ce91">&#9670;&nbsp;</a></span>mmconfig_read_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_read_uint32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unsigned integer stored in persistent store identified by the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>Returns the unsigned integer in this, it is converted from string. On error, the value is untouched, so can be preloaded with a default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_NOT_FOUND</code> if the specified key was not found <code>MMCONFIG_ERR_INCORRECT_TYPE</code> if the data pointed to by the key is not an unsigned integer or hexadecimal number represented as a string </dd></dl>

</div>
</div>
<a id="gac4d12564d7dc99fcdec5aac2cf571669" name="gac4d12564d7dc99fcdec5aac2cf571669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4d12564d7dc99fcdec5aac2cf571669">&#9670;&nbsp;</a></span>mmconfig_validate_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_validate_key </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates an entire key intended for data storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> if the key is valid, or <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the key ends in an asterisk '*' it will fail this validation. However, it is still valid for deleting multiple keys (where any key matching up to the asterisk will be deleted). </dd></dl>

</div>
</div>
<a id="gaf66c8ee2ad518ce126006eef13f53eb5" name="gaf66c8ee2ad518ce126006eef13f53eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf66c8ee2ad518ce126006eef13f53eb5">&#9670;&nbsp;</a></span>mmconfig_validate_key_character()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_validate_key_character </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates a single character intended to make up a key for data storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> if the character is valid, or <code>MMCONFIG_ERR_INVALID_KEY</code> if character is invalid</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Additional restrictions apply to the first character of a key If the character is an asterisk '*' it will fail this validation. '*' is still valid for deleting multiple keys (where any key matching up to the asterisk will be deleted). </dd></dl>

</div>
</div>
<a id="ga635c965295967a5965b6bc46c763e173" name="ga635c965295967a5965b6bc46c763e173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga635c965295967a5965b6bc46c763e173">&#9670;&nbsp;</a></span>mmconfig_write_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_write_bool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given boolean to a string and writes to persistent store. </p>
<p >If there is already data with the same key then it will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>The boolean value to be written, it is converted to string and written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid Other negative number for other errors. </dd></dl>

</div>
</div>
<a id="gab1379a02dfbef05b86b02a475f09f484" name="gab1379a02dfbef05b86b02a475f09f484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1379a02dfbef05b86b02a475f09f484">&#9670;&nbsp;</a></span>mmconfig_write_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_write_data </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the raw data to persistent store location identified by key. </p>
<p >If there is already data with the same key (ignoring case) then it will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">data</td><td>The binary data to be written, can contain nulls and need not be null terminated. Can be a pointer to a structure or any arbitrary data to be written. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the binary data to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_FULL</code> if insufficient space to write data Other negative number for other errors. </dd></dl>

</div>
</div>
<a id="ga093ef5caa1ee5d2d49ac26510e3f8d3b" name="ga093ef5caa1ee5d2d49ac26510e3f8d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga093ef5caa1ee5d2d49ac26510e3f8d3b">&#9670;&nbsp;</a></span>mmconfig_write_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_write_int </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given integer to a string and writes to persistent store. </p>
<p >If there is already data with the same key then it will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>The integer to be written, it is converted to string and written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid Other negative number for other errors. </dd></dl>

</div>
</div>
<a id="gad75d2af944e63a2b6f5615ba8a4e7ad6" name="gad75d2af944e63a2b6f5615ba8a4e7ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad75d2af944e63a2b6f5615ba8a4e7ad6">&#9670;&nbsp;</a></span>mmconfig_write_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_write_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the null terminated string to persistent store location identified by key. </p>
<p >If there is already data with the same key (ignoring case) then it will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>The data to be written, must be a null terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid <code>MMCONFIG_ERR_FULL</code> if insufficient space to write data Other negative number for other errors. </dd></dl>

</div>
</div>
<a id="ga8339629d27f454f568df2f68e457d5bd" name="ga8339629d27f454f568df2f68e457d5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8339629d27f454f568df2f68e457d5bd">&#9670;&nbsp;</a></span>mmconfig_write_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_write_uint32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given unsigned integer to a string and writes to persistent store. </p>
<p >If there is already data with the same key then it will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifies the data element in persistent storage and is a case insensitive alphanumeric (plus underscore) string starting with an alpha. Same rules as a C variable name, but case insensitive. Must be a null terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned integer to be written, it is converted to string and written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error returns: <code>MMCONFIG_ERR_INVALID_KEY</code> if key is invalid Other negative number for other errors. </dd></dl>

</div>
</div>
<a id="ga72d00758a37662b66f89386065f3e13f" name="ga72d00758a37662b66f89386065f3e13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72d00758a37662b66f89386065f3e13f">&#9670;&nbsp;</a></span>mmconfig_write_update_node_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmconfig_write_update_node_list </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmmconfig__update__node.html">mmconfig_update_node</a> *&#160;</td>
          <td class="paramname"><em>node_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all updates from the update node list to persistent store. </p>
<p >If there is already data with the same key (ignoring case) then it will be replaced. If data is NULL then it will be deleted.</p>
<dl class="section note"><dt>Note</dt><dd>It is up to the caller to ensure that there is only one non-NULL data item per key, otherwise both entries will be written. The caller retains ownership of the list and is responsible for freeing the nodes after the write.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_list</td><td>Pointer to a linked list of nodes to be included in the update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>MMCONFIG_OK</code> on success. On error, no update takes place and the return code is: <code>MMCONFIG_ERR_INVALID_KEY</code> if a key in the list is invalid <code>MMCONFIG_ERR_FULL</code> if insufficient space to write data Other negative number for other errors. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright 2021 Morse Micro </li>
  </ul>
</div>
</body>
</html>
